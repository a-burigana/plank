/* -*- c++ -*- File generated by the BNF Converter (bnfc 2.9.4). */

/* Parser definition to be used with Bison. */

/* Generate header file for lexer. */
%defines "Bison.H"

/* Reentrant parser */
%pure_parser
  /* From Bison 2.3b (2008): %define api.pure full */
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }

/* Turn on line/column tracking in the epddl_lloc structure: */
%locations

/* Argument to the parser to be filled with the parsed tree. */
%parse-param { YYSTYPE *result }

%{
/* Begin C preamble code */

#include <algorithm> /* for std::reverse */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Absyn.H"

#define YYMAXDEPTH 10000000

/* The type yyscan_t is defined by flex, but we need it in the parser already. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE epddl__scan_string(const char *str, yyscan_t scanner);
extern void epddl__delete_buffer(YY_BUFFER_STATE buf, yyscan_t scanner);

extern void epddl_lex_destroy(yyscan_t scanner);
extern char* epddl_get_text(yyscan_t scanner);

extern yyscan_t epddl__initialize_lexer(FILE * inp);

/* End C preamble code */
%}

%union
{
  int    _int;
  char   _char;
  double _double;
  char*  _string;
  Name* _name;
  AgentName* _agentname;
  ModalityName* _modalityname;
  Variable* _variable;
  MainDef* maindef_;
  DomainDef* domaindef_;
  DomainItemDef* domainitemdef_;
  ListDomainItemDef* listdomainitemdef_;
  DomainLibrariesNameDef* domainlibrariesnamedef_;
  RequireDef* requiredef_;
  TypesDef* typesdef_;
  PredicateListDef* predicatelistdef_;
  PredicateDef* predicatedef_;
  ListPredicateDef* listpredicatedef_;
  ModalitiesDef* modalitiesdef_;
  ObservabilityGroupsDef* observabilitygroupsdef_;
  ActionDef* actiondef_;
  ActionParameterDef* actionparameterdef_;
  ActionTypeSignatureDef* actiontypesignaturedef_;
  ActionPreDef* actionpredef_;
  Precondition* precondition_;
  ActionObsDef* actionobsdef_;
  ObsConditionDef* obsconditiondef_;
  ListObsConditionDef* listobsconditiondef_;
  LibraryDef* librarydef_;
  LibraryItemDef* libraryitemdef_;
  ListLibraryItemDef* listlibraryitemdef_;
  ActionTypeDef* actiontypedef_;
  ActionTypeParameterDef* actiontypeparameterdef_;
  ActionTypeFrameDef* actiontypeframedef_;
  ActionTypeEventsDef* actiontypeeventsdef_;
  ActionTypeRelDef* actiontypereldef_;
  ActionTypeDesDef* actiontypedesdef_;
  EventSignature* eventsignature_;
  ListEventSignature* listeventsignature_;
  ActionRelations* actionrelations_;
  EventRelation* eventrelation_;
  ListEventRelation* listeventrelation_;
  EventNamePair* eventnamepair_;
  ListEventNamePair* listeventnamepair_;
  EventDef* eventdef_;
  EventParameterDef* eventparameterdef_;
  EventPreDef* eventpredef_;
  EventPostDef* eventpostdef_;
  EventPostconditions* eventpostconditions_;
  LiteralPostcondition* literalpostcondition_;
  ListLiteralPostcondition* listliteralpostcondition_;
  Postcondition* postcondition_;
  ProblemDef* problemdef_;
  ProblemItemDef* problemitemdef_;
  ListProblemItemDef* listproblemitemdef_;
  ProblemDomainNameDef* problemdomainnamedef_;
  AgentNamesDef* agentnamesdef_;
  AgentGroupsListDef* agentgroupslistdef_;
  AgentGroupDef* agentgroupdef_;
  ListAgentGroupDef* listagentgroupdef_;
  ObjectNamesDef* objectnamesdef_;
  InitDef* initdef_;
  InitialStateDescr* initialstatedescr_;
  FTheoryFormula* ftheoryformula_;
  ListFTheoryFormula* listftheoryformula_;
  KPredicateFormula* kpredicateformula_;
  KWPredicateFormula* kwpredicateformula_;
  NotKWPredicateFormula* notkwpredicateformula_;
  InitialModelDef* initialmodeldef_;
  ModelWorldsDef* modelworldsdef_;
  ModelRelDef* modelreldef_;
  ModelValDef* modelvaldef_;
  ModelDesDef* modeldesdef_;
  ModelRelations* modelrelations_;
  ModelValuation* modelvaluation_;
  WorldRelation* worldrelation_;
  ListWorldRelation* listworldrelation_;
  WorldNamePair* worldnamepair_;
  ListWorldNamePair* listworldnamepair_;
  WorldValuation* worldvaluation_;
  ListWorldValuation* listworldvaluation_;
  GoalDef* goaldef_;
  Formula* formula_;
  ListFormula* listformula_;
  AtomicFormula* atomicformula_;
  AtomicEqFormula* atomiceqformula_;
  MetaTerm* metaterm_;
  ListMetaTerm* listmetaterm_;
  Term* term_;
  Modality* modality_;
  SingleModality* singlemodality_;
  GroupModality* groupmodality_;
  ModalityLabel* modalitylabel_;
  KnowsWhether* knowswhether_;
  Literal* literal_;
  ListLiteral* listliteral_;
  PredicateFormula* predicateformula_;
  ListPredicateFormula* listpredicateformula_;
  BasicTypedIdentList* basictypedidentlist_;
  BasicTypedVariableList* basictypedvariablelist_;
  TypedVariableList* typedvariablelist_;
  PredicateName* predicatename_;
  ModalityAgent* modalityagent_;
  ListModalityAgent* listmodalityagent_;
  ModalityAgentGroup* modalityagentgroup_;
  AgentGroupName* agentgroupname_;
  ObservingAgentGroup* observingagentgroup_;
  ListObservingAgentGroup* listobservingagentgroup_;
  ObservingAgent* observingagent_;
  AgentList* agentlist_;
  AllAgents* allagents_;
  AnonVarAgent* anonvaragent_;
  Parameter* parameter_;
  ListParameter* listparameter_;
  BasicParameter* basicparameter_;
  Type* type_;
  BasicType* basictype_;
  CompoundType* compoundtype_;
  ReservedBasicType* reservedbasictype_;
  ReservedFormulaType* reservedformulatype_;
  LibraryName* libraryname_;
  ListLibraryName* listlibraryname_;
  ActionTypeName* actiontypename_;
  ReservedActionTypeName* reservedactiontypename_;
  EventName* eventname_;
  ListEventName* listeventname_;
  ReservedEventName* reservedeventname_;
  ActionName* actionname_;
  ModelName* modelname_;
  WorldName* worldname_;
  ListWorldName* listworldname_;
  RequireKey* requirekey_;
  ListRequireKey* listrequirekey_;
  TrivialDef* trivialdef_;
  ListName* listname_;
  ListAgentName* listagentname_;
  ListModalityName* listmodalityname_;
  ListVariable* listvariable_;
}

%{
void yyerror(YYLTYPE *loc, yyscan_t scanner, YYSTYPE *result, const char *msg)
{
  fprintf(stderr, "error: %d,%d: %s at %s\n",
    loc->first_line, loc->first_column, msg, epddl_get_text(scanner));
}

int yyparse(yyscan_t scanner, YYSTYPE *result);

extern int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner);
%}

%token          _ERROR_
%token          _LPAREN           /* ( */
%token          _RPAREN           /* ) */
%token          _MINUS            /* - */
%token          _SYMB_8           /* :action */
%token          _SYMB_10          /* :action-type */
%token          _SYMB_2           /* :action-type-libraries */
%token          _SYMB_21          /* :agent-groups */
%token          _SYMB_20          /* :agents */
%token          _SYMB_54          /* :common-knowledge */
%token          _SYMB_43          /* :del */
%token          _SYMB_16          /* :designated */
%token          _SYMB_48          /* :disjunctive-preconditions */
%token          _SYMB_19          /* :domain */
%token          _SYMB_55          /* :dynamic-common-knowledge */
%token          _SYMB_45          /* :equality */
%token          _SYMB_17          /* :event */
%token          _SYMB_14          /* :events */
%token          _SYMB_49          /* :existential-preconditions */
%token          _SYMB_13          /* :frame-of-reference */
%token          _SYMB_32          /* :goal */
%token          _SYMB_25          /* :init */
%token          _SYMB_56          /* :ma-star */
%token          _SYMB_59          /* :ma-star-announcement */
%token          _SYMB_60          /* :ma-star-finitary-theory */
%token          _SYMB_57          /* :ma-star-ontic */
%token          _SYMB_58          /* :ma-star-sensing */
%token          _SYMB_63          /* :maximum-modal-depth */
%token          _SYMB_62          /* :maximum-postconditions-depth */
%token          _SYMB_61          /* :maximum-preconditions-depth */
%token          _SYMB_52          /* :modal-postconditions */
%token          _SYMB_51          /* :modal-preconditions */
%token          _SYMB_6           /* :modalities */
%token          _SYMB_29          /* :model */
%token          _SYMB_26          /* :model-name */
%token          _SYMB_47          /* :negative-preconditions */
%token          _SYMB_24          /* :objects */
%token          _SYMB_12          /* :observability-conditions */
%token          _SYMB_7           /* :observability-groups */
%token          _SYMB_53          /* :ontic-change */
%token          _SYMB_46          /* :parameter-lists */
%token          _SYMB_9           /* :parameters */
%token          _SYMB_18          /* :postconditions */
%token          _SYMB_11          /* :precondition */
%token          _SYMB_5           /* :predicates */
%token          _SYMB_15          /* :relations */
%token          _SYMB_3           /* :requirements */
%token          _SYMB_4           /* :types */
%token          _SYMB_44          /* :typing */
%token          _SYMB_50          /* :universal-preconditions */
%token          _SYMB_31          /* :valuation */
%token          _SYMB_30          /* :worlds */
%token          _LT               /* < */
%token          _EQ               /* = */
%token          _GT               /* > */
%token          _SYMB_40          /* ?_ */
%token          _KW_All           /* All */
%token          _LBRACK           /* [ */
%token          _RBRACK           /* ] */
%token          _KW_agent         /* agent */
%token          _KW_and           /* and */
%token          _KW_announcement  /* announcement */
%token          _KW_as            /* as */
%token          _KW_define        /* define */
%token          _KW_domain        /* domain */
%token          _SYMB_37          /* e. */
%token          _KW_false         /* false */
%token          _KW_formula       /* formula */
%token          _SYMB_42          /* idle-event */
%token          _KW_if            /* if */
%token          _KW_iff           /* iff */
%token          _KW_imply         /* imply */
%token          _SYMB_36          /* kw. */
%token          _KW_library       /* library */
%token          _KW_literal       /* literal */
%token          _KW_not           /* not */
%token          _KW_ontic         /* ontic */
%token          _KW_or            /* or */
%token          _KW_otherwise     /* otherwise */
%token          _KW_predicate     /* predicate */
%token          _SYMB_41          /* predicate-formula */
%token          _KW_problem       /* problem */
%token          _SYMB_38          /* s. */
%token          _KW_sensing       /* sensing */
%token          _KW_true          /* true */
%token          _LBRACE           /* { */
%token          _RBRACE           /* } */
%token<_string> T_AgentName       /* AgentName */
%token<_string> T_ModalityName    /* ModalityName */
%token<_string> T_Name            /* Name */
%token<_string> T_Variable        /* Variable */
%token<_int>    _INTEGER_

%type <_name> Name
%type <_agentname> AgentName
%type <_modalityname> ModalityName
%type <_variable> Variable
%type <maindef_> MainDef
%type <domaindef_> DomainDef
%type <domainitemdef_> DomainItemDef
%type <listdomainitemdef_> ListDomainItemDef
%type <domainlibrariesnamedef_> DomainLibrariesNameDef
%type <requiredef_> RequireDef
%type <typesdef_> TypesDef
%type <predicatelistdef_> PredicateListDef
%type <predicatedef_> PredicateDef
%type <listpredicatedef_> ListPredicateDef
%type <modalitiesdef_> ModalitiesDef
%type <observabilitygroupsdef_> ObservabilityGroupsDef
%type <actiondef_> ActionDef
%type <actionparameterdef_> ActionParameterDef
%type <actiontypesignaturedef_> ActionTypeSignatureDef
%type <actionpredef_> ActionPreDef
%type <precondition_> Precondition
%type <actionobsdef_> ActionObsDef
%type <obsconditiondef_> ObsConditionDef
%type <listobsconditiondef_> ListObsConditionDef
%type <librarydef_> LibraryDef
%type <libraryitemdef_> LibraryItemDef
%type <listlibraryitemdef_> ListLibraryItemDef
%type <actiontypedef_> ActionTypeDef
%type <actiontypeparameterdef_> ActionTypeParameterDef
%type <actiontypeframedef_> ActionTypeFrameDef
%type <actiontypeeventsdef_> ActionTypeEventsDef
%type <actiontypereldef_> ActionTypeRelDef
%type <actiontypedesdef_> ActionTypeDesDef
%type <eventsignature_> EventSignature
%type <listeventsignature_> ListEventSignature
%type <actionrelations_> ActionRelations
%type <eventrelation_> EventRelation
%type <listeventrelation_> ListEventRelation
%type <eventnamepair_> EventNamePair
%type <listeventnamepair_> ListEventNamePair
%type <eventdef_> EventDef
%type <eventparameterdef_> EventParameterDef
%type <eventpredef_> EventPreDef
%type <eventpostdef_> EventPostDef
%type <eventpostconditions_> EventPostconditions
%type <literalpostcondition_> LiteralPostcondition
%type <listliteralpostcondition_> ListLiteralPostcondition
%type <postcondition_> Postcondition
%type <problemdef_> ProblemDef
%type <problemitemdef_> ProblemItemDef
%type <listproblemitemdef_> ListProblemItemDef
%type <problemdomainnamedef_> ProblemDomainNameDef
%type <agentnamesdef_> AgentNamesDef
%type <agentgroupslistdef_> AgentGroupsListDef
%type <agentgroupdef_> AgentGroupDef
%type <listagentgroupdef_> ListAgentGroupDef
%type <objectnamesdef_> ObjectNamesDef
%type <initdef_> InitDef
%type <initialstatedescr_> InitialStateDescr
%type <ftheoryformula_> FTheoryFormula
%type <listftheoryformula_> ListFTheoryFormula
%type <kpredicateformula_> KPredicateFormula
%type <kwpredicateformula_> KWPredicateFormula
%type <notkwpredicateformula_> NotKWPredicateFormula
%type <initialmodeldef_> InitialModelDef
%type <modelworldsdef_> ModelWorldsDef
%type <modelreldef_> ModelRelDef
%type <modelvaldef_> ModelValDef
%type <modeldesdef_> ModelDesDef
%type <modelrelations_> ModelRelations
%type <modelvaluation_> ModelValuation
%type <worldrelation_> WorldRelation
%type <listworldrelation_> ListWorldRelation
%type <worldnamepair_> WorldNamePair
%type <listworldnamepair_> ListWorldNamePair
%type <worldvaluation_> WorldValuation
%type <listworldvaluation_> ListWorldValuation
%type <goaldef_> GoalDef
%type <formula_> Formula
%type <listformula_> ListFormula
%type <atomicformula_> AtomicFormula
%type <atomiceqformula_> AtomicEqFormula
%type <metaterm_> MetaTerm
%type <listmetaterm_> ListMetaTerm
%type <term_> Term
%type <modality_> Modality
%type <singlemodality_> SingleModality
%type <groupmodality_> GroupModality
%type <modalitylabel_> ModalityLabel
%type <knowswhether_> KnowsWhether
%type <literal_> Literal
%type <listliteral_> ListLiteral
%type <predicateformula_> PredicateFormula
%type <listpredicateformula_> ListPredicateFormula
%type <basictypedidentlist_> BasicTypedIdentList
%type <basictypedvariablelist_> BasicTypedVariableList
%type <typedvariablelist_> TypedVariableList
%type <predicatename_> PredicateName
%type <modalityagent_> ModalityAgent
%type <listmodalityagent_> ListModalityAgent
%type <modalityagentgroup_> ModalityAgentGroup
%type <agentgroupname_> AgentGroupName
%type <observingagentgroup_> ObservingAgentGroup
%type <listobservingagentgroup_> ListObservingAgentGroup
%type <observingagent_> ObservingAgent
%type <agentlist_> AgentList
%type <allagents_> AllAgents
%type <anonvaragent_> AnonVarAgent
%type <parameter_> Parameter
%type <listparameter_> ListParameter
%type <basicparameter_> BasicParameter
%type <type_> Type
%type <basictype_> BasicType
%type <compoundtype_> CompoundType
%type <reservedbasictype_> ReservedBasicType
%type <reservedformulatype_> ReservedFormulaType
%type <libraryname_> LibraryName
%type <listlibraryname_> ListLibraryName
%type <actiontypename_> ActionTypeName
%type <reservedactiontypename_> ReservedActionTypeName
%type <eventname_> EventName
%type <listeventname_> ListEventName
%type <reservedeventname_> ReservedEventName
%type <actionname_> ActionName
%type <modelname_> ModelName
%type <worldname_> WorldName
%type <listworldname_> ListWorldName
%type <requirekey_> RequireKey
%type <listrequirekey_> ListRequireKey
%type <trivialdef_> TrivialDef
%type <listname_> ListName
%type <listagentname_> ListAgentName
%type <listmodalityname_> ListModalityName
%type <listvariable_> ListVariable

%start MainDef

%%

MainDef : DomainDef { $$ = new Domain($1); result->maindef_ = $$; }
  | LibraryDef { $$ = new ActionTypeLibrary($1); result->maindef_ = $$; }
  | ProblemDef { $$ = new Problem($1); result->maindef_ = $$; }
;
DomainDef : _LPAREN _KW_define _LPAREN _KW_domain Name _RPAREN ListDomainItemDef _RPAREN { $$ = new EPDDLDomain($5, $7); }
;
DomainItemDef : DomainLibrariesNameDef { $$ = new EPDDLDomLibrary($1); }
  | RequireDef { $$ = new EPDDLDomRequire($1); }
  | TypesDef { $$ = new EPDDLDomTypes($1); }
  | PredicateListDef { $$ = new EPDDLDomPredicates($1); }
  | ModalitiesDef { $$ = new EPDDLDomModalities($1); }
  | ObservabilityGroupsDef { $$ = new EPDDLDomObsGroups($1); }
  | ActionDef { $$ = new EPDDLDomAction($1); }
;
ListDomainItemDef : /* empty */ { $$ = new ListDomainItemDef(); }
  | ListDomainItemDef DomainItemDef { $1->push_back($2); $$ = $1; }
;
DomainLibrariesNameDef : _LPAREN _SYMB_2 ListLibraryName _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new EPDDLDomLibraryNames($3); }
;
RequireDef : _LPAREN _SYMB_3 ListRequireKey _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new EPDDLRequire($3); }
;
TypesDef : _LPAREN _SYMB_4 BasicTypedIdentList _RPAREN { $$ = new EPDDLTypes($3); }
;
PredicateListDef : _LPAREN _SYMB_5 ListPredicateDef _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new EPDDLPredicateList($3); }
;
PredicateDef : _LPAREN PredicateName BasicTypedVariableList _RPAREN { $$ = new EPDDLPredicateDef($2, $3); }
;
ListPredicateDef : PredicateDef { $$ = new ListPredicateDef(); $$->push_back($1); }
  | PredicateDef ListPredicateDef { $2->push_back($1); $$ = $2; }
;
ModalitiesDef : _LPAREN _SYMB_6 ListModalityName _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new EPDDLModalities($3); }
;
ObservabilityGroupsDef : _LPAREN _SYMB_7 ListObservingAgentGroup _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new EPDDLObsGroupsNames($3); }
;
ActionDef : _LPAREN _SYMB_8 ActionName ActionParameterDef ActionTypeSignatureDef ActionPreDef ActionObsDef _RPAREN { $$ = new EPDDLAction($3, $4, $5, $6, $7); }
;
ActionParameterDef : _SYMB_9 _LPAREN BasicTypedVariableList _RPAREN { $$ = new ActionPar($3); }
;
ActionTypeSignatureDef : _SYMB_10 _LPAREN ActionTypeName ListParameter _RPAREN { $$ = new ActionSignature($3, $4); }
;
ActionPreDef : _SYMB_11 Precondition { $$ = new ActionPre($2); }
;
Precondition : Formula { $$ = new FormulaPrecondition($1); }
  | TrivialDef { $$ = new TrivialPrecondition($1); }
;
ActionObsDef : _SYMB_12 ListObsConditionDef { std::reverse($2->begin(),$2->end()) ;$$ = new ActionObs($2); }
  | /* empty */ { $$ = new EmptyActionObs(); }
;
ObsConditionDef : _LPAREN ObservingAgent ObservingAgentGroup _RPAREN { $$ = new EmptyObsCond($2, $3); }
  | _LPAREN ObservingAgent ObservingAgentGroup _KW_if Formula _RPAREN { $$ = new ObsCond($2, $3, $5); }
  | _LPAREN _KW_otherwise ObservingAgent ObservingAgentGroup _RPAREN { $$ = new ObsOtherwiseCond($3, $4); }
;
ListObsConditionDef : ObsConditionDef { $$ = new ListObsConditionDef(); $$->push_back($1); }
  | ObsConditionDef ListObsConditionDef { $2->push_back($1); $$ = $2; }
;
LibraryDef : _LPAREN _KW_define _LPAREN _KW_library Name _RPAREN ListLibraryItemDef _RPAREN { $$ = new EPDDLLibrary($5, $7); }
;
LibraryItemDef : RequireDef { $$ = new EPDDLLibRequire($1); }
  | ModalitiesDef { $$ = new EPDDLLibModalities($1); }
  | ObservabilityGroupsDef { $$ = new EPDDLLibObsGroups($1); }
  | ActionTypeDef { $$ = new EPDDLLibActionType($1); }
  | EventDef { $$ = new EPDDLLibEvent($1); }
;
ListLibraryItemDef : /* empty */ { $$ = new ListLibraryItemDef(); }
  | ListLibraryItemDef LibraryItemDef { $1->push_back($2); $$ = $1; }
;
ActionTypeDef : _LPAREN _SYMB_10 ActionTypeName ActionTypeParameterDef ActionTypeFrameDef ActionTypeEventsDef ActionTypeRelDef ActionTypeDesDef _RPAREN { $$ = new EPDDLActType($3, $4, $5, $6, $7, $8); }
;
ActionTypeParameterDef : _SYMB_9 _LPAREN TypedVariableList _RPAREN { $$ = new ActTypePar($3); }
;
ActionTypeFrameDef : _SYMB_13 _LPAREN ListObservingAgentGroup _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new ActTypeFrame($3); }
  | /* empty */ { $$ = new EmptyActTypeFrame(); }
;
ActionTypeEventsDef : _SYMB_14 ListEventSignature { std::reverse($2->begin(),$2->end()) ;$$ = new ActTypeEvents($2); }
;
ActionTypeRelDef : _SYMB_15 ActionRelations { $$ = new ActTypeRel($2); }
;
ActionTypeDesDef : _SYMB_16 _LPAREN ListEventName _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new ActTypeDes($3); }
;
EventSignature : _LPAREN EventName ListParameter _RPAREN { $$ = new EventSign($2, $3); }
;
ListEventSignature : EventSignature { $$ = new ListEventSignature(); $$->push_back($1); }
  | EventSignature ListEventSignature { $2->push_back($1); $$ = $2; }
;
ActionRelations : ListEventRelation { std::reverse($1->begin(),$1->end()) ;$$ = new EventsActionRel($1); }
  | TrivialDef { $$ = new TrivialActionRel($1); }
;
EventRelation : _LPAREN AgentList ListEventNamePair _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new EventRel($2, $3); }
  | _LPAREN AgentList TrivialDef _RPAREN { $$ = new TrivialEventRel($2, $3); }
;
ListEventRelation : EventRelation { $$ = new ListEventRelation(); $$->push_back($1); }
  | EventRelation ListEventRelation { $2->push_back($1); $$ = $2; }
;
EventNamePair : _LPAREN EventName EventName _RPAREN { $$ = new EventPair($2, $3); }
;
ListEventNamePair : EventNamePair { $$ = new ListEventNamePair(); $$->push_back($1); }
  | EventNamePair ListEventNamePair { $2->push_back($1); $$ = $2; }
;
EventDef : _LPAREN _SYMB_17 EventName EventParameterDef EventPreDef EventPostDef _RPAREN { $$ = new EPDDLEvent($3, $4, $5, $6); }
;
EventParameterDef : _SYMB_9 _LPAREN TypedVariableList _RPAREN { $$ = new EventPar($3); }
;
EventPreDef : _SYMB_11 Precondition { $$ = new EventPre($2); }
;
EventPostDef : _SYMB_18 EventPostconditions { $$ = new EventPost($2); }
  | /* empty */ { $$ = new EmptyEventPost(); }
;
EventPostconditions : ListLiteralPostcondition { std::reverse($1->begin(),$1->end()) ;$$ = new Postconditions($1); }
  | TrivialDef { $$ = new TrivialPostconditions($1); }
;
LiteralPostcondition : _LPAREN Literal _KW_iff Postcondition _RPAREN { $$ = new LiteralPost($2, $4); }
  | _LPAREN Literal _RPAREN { $$ = new TrivialLiteralPost($2); }
;
ListLiteralPostcondition : LiteralPostcondition { $$ = new ListLiteralPostcondition(); $$->push_back($1); }
  | LiteralPostcondition ListLiteralPostcondition { $2->push_back($1); $$ = $2; }
;
Postcondition : Formula { $$ = new FormulaPostcondition($1); }
  | TrivialDef { $$ = new TrivialPostcondition($1); }
;
ProblemDef : _LPAREN _KW_define _LPAREN _KW_problem Name _RPAREN ListProblemItemDef _RPAREN { $$ = new EPDDLProblem($5, $7); }
;
ProblemItemDef : ProblemDomainNameDef { $$ = new EPDDLProbDomain($1); }
  | RequireDef { $$ = new EPDDLProbRequire($1); }
  | ModalitiesDef { $$ = new EPDDLProbModalities($1); }
  | AgentNamesDef { $$ = new EPDDLProbAgents($1); }
  | AgentGroupsListDef { $$ = new EPDDLProbAgentGroups($1); }
  | ObjectNamesDef { $$ = new EPDDLProbObjects($1); }
  | InitDef { $$ = new EPDDLProbInit($1); }
  | InitialModelDef { $$ = new EPDDLProbInitModel($1); }
  | GoalDef { $$ = new EPDDLProbGoal($1); }
;
ListProblemItemDef : /* empty */ { $$ = new ListProblemItemDef(); }
  | ListProblemItemDef ProblemItemDef { $1->push_back($2); $$ = $1; }
;
ProblemDomainNameDef : _LPAREN _SYMB_19 Name _RPAREN { $$ = new EPDDLDomainName($3); }
;
AgentNamesDef : _LPAREN _SYMB_20 ListAgentName _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new EPDDLAgentNames($3); }
;
AgentGroupsListDef : _LPAREN _SYMB_21 ListAgentGroupDef _RPAREN { $$ = new EPDDLAgentGroupsList($3); }
;
AgentGroupDef : _LPAREN _LBRACE ListAgentName _RBRACE _KW_as AgentGroupName _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new EPDDLAgentGroupDef($3, $6); }
;
ListAgentGroupDef : /* empty */ { $$ = new ListAgentGroupDef(); }
  | ListAgentGroupDef AgentGroupDef { $1->push_back($2); $$ = $1; }
;
ObjectNamesDef : _LPAREN _SYMB_24 BasicTypedIdentList _RPAREN { $$ = new EPDDLObjectNames($3); }
;
InitDef : _LPAREN _SYMB_25 InitialStateDescr _RPAREN { $$ = new EPDDLInitialState($3); }
;
InitialStateDescr : ListFTheoryFormula { std::reverse($1->begin(),$1->end()) ;$$ = new FinitaryTheoryDescr($1); }
  | _LPAREN _SYMB_26 ModelName _RPAREN { $$ = new InitialModelDescr($3); }
;
FTheoryFormula : PredicateFormula { $$ = new FTheoryPredForm($1); }
  | _LBRACK AllAgents _RBRACK PredicateFormula { $$ = new FTheoryCKPredForm($2, $4); }
  | _LBRACK AllAgents _RBRACK KPredicateFormula { $$ = new FTheoryCKKPredForm($2, $4); }
  | _LBRACK AllAgents _RBRACK KWPredicateFormula { $$ = new FTheoryCKOrKPredForm($2, $4); }
  | _LBRACK AllAgents _RBRACK NotKWPredicateFormula { $$ = new FTheoryCKAndKPredForm($2, $4); }
  | _LPAREN FTheoryFormula _RPAREN { $$ = $2; }
;
ListFTheoryFormula : FTheoryFormula { $$ = new ListFTheoryFormula(); $$->push_back($1); }
  | FTheoryFormula ListFTheoryFormula { $2->push_back($1); $$ = $2; }
;
KPredicateFormula : _LBRACK AgentName _RBRACK PredicateFormula { $$ = new KPredFormula($2, $4); }
  | _LPAREN KPredicateFormula _RPAREN { $$ = $2; }
;
KWPredicateFormula : KnowsWhether PredicateFormula { $$ = new KWPredFormula($1, $2); }
  | _LPAREN KWPredicateFormula _RPAREN { $$ = $2; }
;
NotKWPredicateFormula : _LPAREN _KW_not KnowsWhether PredicateFormula _RPAREN { $$ = new NotKWPredFormula($3, $4); }
  | _LPAREN NotKWPredicateFormula _RPAREN { $$ = $2; }
;
InitialModelDef : _LPAREN _SYMB_29 ModelName ModelWorldsDef ModelRelDef ModelValDef ModelDesDef _RPAREN { $$ = new EPDDLInitialModel($3, $4, $5, $6, $7); }
;
ModelWorldsDef : _SYMB_30 _LPAREN ListWorldName _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new ModelWorlds($3); }
;
ModelRelDef : _SYMB_15 ModelRelations { $$ = new ModelRel($2); }
;
ModelValDef : _SYMB_31 ModelValuation { $$ = new ModelVal($2); }
;
ModelDesDef : _SYMB_16 _LPAREN ListWorldName _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new ModelDes($3); }
;
ModelRelations : ListWorldRelation { std::reverse($1->begin(),$1->end()) ;$$ = new WorldsModelRel($1); }
  | TrivialDef { $$ = new TrivialModelRel($1); }
;
ModelValuation : ListWorldValuation { std::reverse($1->begin(),$1->end()) ;$$ = new WorldsModelVal($1); }
  | TrivialDef { $$ = new TrivialModelVal($1); }
;
WorldRelation : _LPAREN AgentList ListWorldNamePair _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new WorldRel($2, $3); }
  | _LPAREN AgentList TrivialDef _RPAREN { $$ = new TrivialWorldRel($2, $3); }
;
ListWorldRelation : WorldRelation { $$ = new ListWorldRelation(); $$->push_back($1); }
  | WorldRelation ListWorldRelation { $2->push_back($1); $$ = $2; }
;
WorldNamePair : _LPAREN WorldName WorldName _RPAREN { $$ = new WorldPair($2, $3); }
;
ListWorldNamePair : WorldNamePair { $$ = new ListWorldNamePair(); $$->push_back($1); }
  | WorldNamePair ListWorldNamePair { $2->push_back($1); $$ = $2; }
;
WorldValuation : _LPAREN WorldName _LBRACK ListLiteral _RBRACK _RPAREN { $$ = new WorldVal($2, $4); }
;
ListWorldValuation : WorldValuation { $$ = new ListWorldValuation(); $$->push_back($1); }
  | WorldValuation ListWorldValuation { $2->push_back($1); $$ = $2; }
;
GoalDef : _LPAREN _SYMB_32 Formula _RPAREN { $$ = new EPDDLGoals($3); }
;
Formula : _LPAREN _KW_imply Formula Formula _RPAREN { $$ = new ImplyFormula($3, $4); }
  | _LPAREN _KW_or Formula ListFormula _RPAREN { std::reverse($4->begin(),$4->end()) ;$$ = new OrFormula($3, $4); }
  | _LPAREN _KW_and Formula ListFormula _RPAREN { std::reverse($4->begin(),$4->end()) ;$$ = new AndFormula($3, $4); }
  | _LPAREN _KW_not Formula _RPAREN { $$ = new NotFormula($3); }
  | Modality Formula { $$ = new ModalFormula($1, $2); }
  | AtomicFormula { $$ = new AtmFormula($1); }
  | AtomicEqFormula { $$ = new AtmEqFormula($1); }
  | _KW_true { $$ = new TrueFormula(); }
  | _KW_false { $$ = new FalseFormula(); }
  | _LPAREN Formula _RPAREN { $$ = $2; }
;
ListFormula : Formula { $$ = new ListFormula(); $$->push_back($1); }
  | Formula ListFormula { $2->push_back($1); $$ = $2; }
;
AtomicFormula : _LPAREN PredicateName ListMetaTerm _RPAREN { $$ = new Predicate($2, $3); }
  | _LPAREN Variable _RPAREN { $$ = new VarFormula($2); }
;
AtomicEqFormula : _LPAREN _EQ Term Term _RPAREN { $$ = new EqFormula($3, $4); }
;
MetaTerm : Term { $$ = new EPDDLMetaTerm($1); }
  | AnonVarAgent { $$ = new EPDDLMetaTermAnonVar($1); }
;
ListMetaTerm : /* empty */ { $$ = new ListMetaTerm(); }
  | ListMetaTerm MetaTerm { $1->push_back($2); $$ = $1; }
;
Term : Name { $$ = new EPDDLTermName($1); }
  | AgentName { $$ = new EPDDLTermAgentName($1); }
  | Variable { $$ = new EPDDLTermVar($1); }
;
Modality : SingleModality { $$ = new EPDDLLabeledMod($1); }
  | GroupModality { $$ = new EPDDLLabeledGroupMod($1); }
;
SingleModality : _LBRACK ModalityLabel ModalityAgent _RBRACK { $$ = new LabBoxMod($2, $3); }
  | _LT ModalityLabel ModalityAgent _GT { $$ = new LabDiamondMod($2, $3); }
;
GroupModality : _LBRACK ModalityLabel ModalityAgentGroup _RBRACK { $$ = new LabBoxGroupMod($2, $3); }
  | _LT ModalityLabel ModalityAgentGroup _GT { $$ = new LabDiamondGroupMod($2, $3); }
;
ModalityLabel : ModalityName { $$ = new ModLabel($1); }
  | _SYMB_36 { $$ = new KnowsWhetherLabel(); }
  | _SYMB_37 { $$ = new EverybodyKnowsLabel(); }
  | _SYMB_38 { $$ = new SomeoneKnowsLabel(); }
  | /* empty */ { $$ = new EmptyModLabel(); }
;
KnowsWhether : _LBRACK _SYMB_36 AgentName _RBRACK { $$ = new KnowsWhetherMod($3); }
;
Literal : AtomicFormula { $$ = new PosLiteral($1); }
  | _LPAREN _KW_not AtomicFormula _RPAREN { $$ = new NegLiteral($3); }
;
ListLiteral : /* empty */ { $$ = new ListLiteral(); }
  | ListLiteral Literal { $1->push_back($2); $$ = $1; }
;
PredicateFormula : _LPAREN _KW_imply PredicateFormula PredicateFormula _RPAREN { $$ = new ImplyPredFormula($3, $4); }
  | _LPAREN _KW_or PredicateFormula ListPredicateFormula _RPAREN { std::reverse($4->begin(),$4->end()) ;$$ = new OrPredFormula($3, $4); }
  | _LPAREN _KW_and PredicateFormula ListPredicateFormula _RPAREN { std::reverse($4->begin(),$4->end()) ;$$ = new AndPredFormula($3, $4); }
  | _LPAREN _KW_not PredicateFormula _RPAREN { $$ = new NotPredFormula($3); }
  | _LPAREN PredicateName ListName _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new LitPredFormula($2, $3); }
;
ListPredicateFormula : PredicateFormula { $$ = new ListPredicateFormula(); $$->push_back($1); }
  | PredicateFormula ListPredicateFormula { $2->push_back($1); $$ = $2; }
;
BasicTypedIdentList : ListName { std::reverse($1->begin(),$1->end()) ;$$ = new IdList($1); }
  | Name ListName _MINUS BasicType BasicTypedIdentList { std::reverse($2->begin(),$2->end()) ;$$ = new TypedIdList($1, $2, $4, $5); }
;
BasicTypedVariableList : ListVariable { std::reverse($1->begin(),$1->end()) ;$$ = new BasicVarList($1); }
  | Variable ListVariable _MINUS BasicType BasicTypedVariableList { std::reverse($2->begin(),$2->end()) ;$$ = new BasicTypedVarList($1, $2, $4, $5); }
;
TypedVariableList : ListVariable { std::reverse($1->begin(),$1->end()) ;$$ = new VarList($1); }
  | Variable ListVariable _MINUS Type TypedVariableList { std::reverse($2->begin(),$2->end()) ;$$ = new TypedVarList($1, $2, $4, $5); }
;
PredicateName : Name { $$ = new EPDDLPredicate($1); }
;
ModalityAgent : AgentName { $$ = new EPDDLModAgent($1); }
  | Variable { $$ = new EPDDLModVarAgent($1); }
  | AnonVarAgent { $$ = new EPDDLModAnonVarAgent($1); }
  | AllAgents { $$ = new EPDDLModAllAgents($1); }
;
ListModalityAgent : ModalityAgent { $$ = new ListModalityAgent(); $$->push_back($1); }
  | ModalityAgent ListModalityAgent { $2->push_back($1); $$ = $2; }
;
ModalityAgentGroup : ModalityAgent ListModalityAgent { std::reverse($2->begin(),$2->end()) ;$$ = new EPDDLModAgList($1, $2); }
;
AgentGroupName : AgentName { $$ = new EPDDLAgentGroup($1); }
  | AllAgents { $$ = new EPDDLAllAgentsGroup($1); }
;
ObservingAgentGroup : AgentName { $$ = new EPDDLObsAgentGroup($1); }
;
ListObservingAgentGroup : ObservingAgentGroup { $$ = new ListObservingAgentGroup(); $$->push_back($1); }
  | ObservingAgentGroup ListObservingAgentGroup { $2->push_back($1); $$ = $2; }
;
ObservingAgent : AgentName { $$ = new EPDDLObsAgent($1); }
  | Variable { $$ = new EPDDLObsVarAgent($1); }
  | AnonVarAgent { $$ = new EPDDLObsAnonVarAgent($1); }
;
AgentList : AgentName { $$ = new EPDDLSingleAgentList($1); }
  | _LBRACK AgentName ListAgentName _RBRACK { std::reverse($3->begin(),$3->end()) ;$$ = new EPDDLAgentNameList($2, $3); }
  | AllAgents { $$ = new EPDDLAllAgentsList($1); }
;
AllAgents : _KW_All { $$ = new EPDDLAllAgents(); }
;
AnonVarAgent : _SYMB_40 { $$ = new EPDDLAnonVarAgent(); }
;
Parameter : BasicParameter { $$ = new EPDDLBasicParam($1); }
  | _LBRACK ListFormula _RBRACK { std::reverse($2->begin(),$2->end()) ;$$ = new EPDDLListParam($2); }
;
ListParameter : /* empty */ { $$ = new ListParameter(); }
  | ListParameter Parameter { $1->push_back($2); $$ = $1; }
;
BasicParameter : Term { $$ = new EPDDLTermParam($1); }
  | Formula { $$ = new EPDDLFormulaParam($1); }
  | TrivialDef { $$ = new EPDDLTrivialParam($1); }
;
Type : BasicType { $$ = new EPDDLBasicType($1); }
  | CompoundType { $$ = new EPDDLCompoundType($1); }
;
BasicType : Name { $$ = new EPDDLBasicTypeName($1); }
  | ReservedBasicType { $$ = new EPDDLBasicResType($1); }
;
CompoundType : _LBRACK ReservedFormulaType _RBRACK { $$ = new EPDDLFormulaListType($2); }
;
ReservedBasicType : ReservedFormulaType { $$ = new ResFormulaType($1); }
  | _KW_agent { $$ = new ResAgentType(); }
;
ReservedFormulaType : _KW_predicate { $$ = new PredicateType(); }
  | _KW_literal { $$ = new LiteralType(); }
  | _SYMB_41 { $$ = new PredFormulaType(); }
  | _KW_formula { $$ = new FormulaType(); }
;
LibraryName : Name { $$ = new EPDDLLibraryName($1); }
;
ListLibraryName : LibraryName { $$ = new ListLibraryName(); $$->push_back($1); }
  | LibraryName ListLibraryName { $2->push_back($1); $$ = $2; }
;
ActionTypeName : ReservedActionTypeName { $$ = new EPDDLResActTypeName($1); }
  | Name { $$ = new EPDDLActTypeName($1); }
;
ReservedActionTypeName : _KW_ontic { $$ = new OntActTypeName(); }
  | _KW_sensing { $$ = new SenActTypeName(); }
  | _KW_announcement { $$ = new AnnActTypeName(); }
;
EventName : ReservedEventName { $$ = new EPDDLResEventName($1); }
  | Name { $$ = new EPDDLEventName($1); }
;
ListEventName : EventName { $$ = new ListEventName(); $$->push_back($1); }
  | EventName ListEventName { $2->push_back($1); $$ = $2; }
;
ReservedEventName : _SYMB_42 { $$ = new IdleEvent(); }
;
ActionName : Name { $$ = new EPDDLActionName($1); }
;
ModelName : Name { $$ = new EPDDLModelName($1); }
;
WorldName : Name { $$ = new EPDDLWorldName($1); }
;
ListWorldName : WorldName { $$ = new ListWorldName(); $$->push_back($1); }
  | WorldName ListWorldName { $2->push_back($1); $$ = $2; }
;
RequireKey : _SYMB_43 { $$ = new EPDDLReqDel(); }
  | _SYMB_44 { $$ = new EPDDLReqTyping(); }
  | _SYMB_45 { $$ = new EPDDLReqEquality(); }
  | _SYMB_46 { $$ = new EPDDLReqParamList(); }
  | _SYMB_47 { $$ = new EPDDLReqNegPre(); }
  | _SYMB_48 { $$ = new EPDDLReqDisPre(); }
  | _SYMB_49 { $$ = new EPDDLReqExiPre(); }
  | _SYMB_50 { $$ = new EPDDLReqUniPre(); }
  | _SYMB_51 { $$ = new EPDDLReqModPre(); }
  | _SYMB_52 { $$ = new EPDDLReqModPost(); }
  | _SYMB_6 { $$ = new EPDDLReqModalities(); }
  | _SYMB_53 { $$ = new EPDDLReqOnticChange(); }
  | _SYMB_54 { $$ = new EPDDLReqCK(); }
  | _SYMB_55 { $$ = new EPDDLReqDynCK(); }
  | _SYMB_56 { $$ = new EPDDLReqMAStar(); }
  | _SYMB_57 { $$ = new EPDDLReqOntic(); }
  | _SYMB_58 { $$ = new EPDDLReqSensing(); }
  | _SYMB_59 { $$ = new EPDDLReqAnnouncement(); }
  | _SYMB_60 { $$ = new EPDDLReqFTheory(); }
  | _LPAREN _SYMB_61 _INTEGER_ _RPAREN { $$ = new EPDDLReqMaxPreDepth($3); }
  | _LPAREN _SYMB_62 _INTEGER_ _RPAREN { $$ = new EPDDLReqMaxPostDepth($3); }
  | _LPAREN _SYMB_63 _INTEGER_ _RPAREN { $$ = new EPDDLReqMaxDepth($3); }
;
ListRequireKey : RequireKey { $$ = new ListRequireKey(); $$->push_back($1); }
  | RequireKey ListRequireKey { $2->push_back($1); $$ = $2; }
;
TrivialDef : _LPAREN _RPAREN { $$ = new EPDDLTrivialDef(); }
;
ListName : /* empty */ { $$ = new ListName(); }
  | Name ListName { $2->push_back($1); $$ = $2; }
;
ListAgentName : AgentName { $$ = new ListAgentName(); $$->push_back($1); }
  | AgentName ListAgentName { $2->push_back($1); $$ = $2; }
;
ListModalityName : /* empty */ { $$ = new ListModalityName(); }
  | ModalityName ListModalityName { $2->push_back($1); $$ = $2; }
;
ListVariable : /* empty */ { $$ = new ListVariable(); }
  | Variable ListVariable { $2->push_back($1); $$ = $2; }
;
Name : T_Name { $$ = new Name($1, @$.first_line); }
;
AgentName : T_AgentName { $$ = new AgentName($1, @$.first_line); }
;
ModalityName : T_ModalityName { $$ = new ModalityName($1, @$.first_line); }
;
Variable : T_Variable { $$ = new Variable($1, @$.first_line); }
;

%%


/* Entrypoint: parse MainDef* from file. */
MainDef* pMainDef(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = epddl__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  epddl_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.maindef_;
  }
}

/* Entrypoint: parse MainDef* from string. */
MainDef* psMainDef(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = epddl__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = epddl__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  epddl__delete_buffer(buf, scanner);
  epddl_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.maindef_;
  }
}



