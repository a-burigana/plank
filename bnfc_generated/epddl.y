/* -*- c++ -*- File generated by the BNF Converter (bnfc 2.9.4). */

/* Parser definition to be used with Bison. */

/* Generate header file for lexer. */
%defines "Bison.H"

/* Reentrant parser */
%pure_parser
  /* From Bison 2.3b (2008): %define api.pure full */
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }

/* Turn on line/column tracking in the epddl_lloc structure: */
%locations

/* Argument to the parser to be filled with the parsed tree. */
%parse-param { YYSTYPE *result }

%{
/* Begin C preamble code */

#include <algorithm> /* for std::reverse */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Absyn.H"

#define YYMAXDEPTH 10000000

/* The type yyscan_t is defined by flex, but we need it in the parser already. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE epddl__scan_string(const char *str, yyscan_t scanner);
extern void epddl__delete_buffer(YY_BUFFER_STATE buf, yyscan_t scanner);

extern void epddl_lex_destroy(yyscan_t scanner);
extern char* epddl_get_text(yyscan_t scanner);

extern yyscan_t epddl__initialize_lexer(FILE * inp);

/* End C preamble code */
%}

%union
{
  int    _int;
  char   _char;
  double _double;
  char*  _string;
  Name* _name;
  AgentName* _agentname;
  ModalityName* _modalityname;
  Variable* _variable;
  MainDef* maindef_;
  DomainDef* domaindef_;
  DomainItemDef* domainitemdef_;
  ListDomainItemDef* listdomainitemdef_;
  DomainLibrariesNameDef* domainlibrariesnamedef_;
  RequireDef* requiredef_;
  TypesDef* typesdef_;
  PredicateListDef* predicatelistdef_;
  PredicateDef* predicatedef_;
  ListPredicateDef* listpredicatedef_;
  ModalitiesDef* modalitiesdef_;
  ObservabilityGroupsDef* observabilitygroupsdef_;
  ActionDef* actiondef_;
  ActionParameterDef* actionparameterdef_;
  ActionConditionsDef* actionconditionsdef_;
  ActionTypeSignatureDef* actiontypesignaturedef_;
  ActionPreDef* actionpredef_;
  ActionObsDef* actionobsdef_;
  ObsConditionDef* obsconditiondef_;
  ListObsConditionDef* listobsconditiondef_;
  LibraryDef* librarydef_;
  LibraryItemDef* libraryitemdef_;
  ListLibraryItemDef* listlibraryitemdef_;
  ActionTypeDef* actiontypedef_;
  ActionTypeParameterDef* actiontypeparameterdef_;
  ActionTypeFrameDef* actiontypeframedef_;
  ActionTypeEventsDef* actiontypeeventsdef_;
  ActionTypeRelDef* actiontypereldef_;
  ActionTypeDesDef* actiontypedesdef_;
  EventSignature* eventsignature_;
  ListEventSignature* listeventsignature_;
  ActionRelations* actionrelations_;
  EventRelation* eventrelation_;
  ListEventRelation* listeventrelation_;
  EventNamePair* eventnamepair_;
  ListEventNamePair* listeventnamepair_;
  EventDef* eventdef_;
  EventParameterDef* eventparameterdef_;
  EventPreDef* eventpredef_;
  EventPostDef* eventpostdef_;
  EventPostconditions* eventpostconditions_;
  Postcondition* postcondition_;
  ListPostcondition* listpostcondition_;
  LiteralPostcondition* literalpostcondition_;
  ListLiteralPostcondition* listliteralpostcondition_;
  ProblemDef* problemdef_;
  ProblemItemDef* problemitemdef_;
  ListProblemItemDef* listproblemitemdef_;
  ProblemDomainNameDef* problemdomainnamedef_;
  AgentNamesDef* agentnamesdef_;
  AgentGroupsListDef* agentgroupslistdef_;
  AgentGroupDef* agentgroupdef_;
  ListAgentGroupDef* listagentgroupdef_;
  ObjectNamesDef* objectnamesdef_;
  StaticPredListDef* staticpredlistdef_;
  StaticPredDef* staticpreddef_;
  ListStaticPredDef* liststaticpreddef_;
  InitDef* initdef_;
  InitialStateDescr* initialstatedescr_;
  FTheoryFormula* ftheoryformula_;
  ListFTheoryFormula* listftheoryformula_;
  KPredicateFormula* kpredicateformula_;
  KWPredicateFormula* kwpredicateformula_;
  NotKWPredicateFormula* notkwpredicateformula_;
  InitialModelDef* initialmodeldef_;
  ModelWorldsDef* modelworldsdef_;
  ModelRelDef* modelreldef_;
  ModelValDef* modelvaldef_;
  ModelDesDef* modeldesdef_;
  ModelRelations* modelrelations_;
  ModelValuation* modelvaluation_;
  WorldRelation* worldrelation_;
  ListWorldRelation* listworldrelation_;
  WorldNamePair* worldnamepair_;
  ListWorldNamePair* listworldnamepair_;
  WorldValuation* worldvaluation_;
  ListWorldValuation* listworldvaluation_;
  GoalDef* goaldef_;
  Formula* formula_;
  ListFormula* listformula_;
  AtomicFormula* atomicformula_;
  AtomicEqFormula* atomiceqformula_;
  FormulaOrEmpty* formulaorempty_;
  MetaTerm* metaterm_;
  ListMetaTerm* listmetaterm_;
  Term* term_;
  ListTerm* listterm_;
  GroundTerm* groundterm_;
  ListGroundTerm* listgroundterm_;
  Modality* modality_;
  SingleModality* singlemodality_;
  GroupModality* groupmodality_;
  ModalityLabel* modalitylabel_;
  KnowsWhether* knowswhether_;
  Literal* literal_;
  ListLiteral* listliteral_;
  ConditionFormula* conditionformula_;
  Condition* condition_;
  ListCondition* listcondition_;
  AtomicCondition* atomiccondition_;
  PredicateFormula* predicateformula_;
  ListPredicateFormula* listpredicateformula_;
  GenericName* genericname_;
  ListGenericName* listgenericname_;
  TypedIdentList* typedidentlist_;
  TypedAgentList* typedagentlist_;
  TypedVariableList* typedvariablelist_;
  PredicateName* predicatename_;
  ModalityAgent* modalityagent_;
  ListModalityAgent* listmodalityagent_;
  ModalityAgentGroup* modalityagentgroup_;
  AgentGroupName* agentgroupname_;
  ObservingAgentGroup* observingagentgroup_;
  ListObservingAgentGroup* listobservingagentgroup_;
  ObservingAgent* observingagent_;
  AgentGroup* agentgroup_;
  AllAgents* allagents_;
  AnonVarAgent* anonvaragent_;
  Parameter* parameter_;
  ListParameter* listparameter_;
  ParameterValue* parametervalue_;
  PostParameterValue* postparametervalue_;
  ListPostParameterValue* listpostparametervalue_;
  Type* type_;
  ReservedType* reservedtype_;
  DomainName* domainname_;
  LibraryName* libraryname_;
  ListLibraryName* listlibraryname_;
  ProblemName* problemname_;
  ActionName* actionname_;
  ActionTypeName* actiontypename_;
  EventName* eventname_;
  ListEventName* listeventname_;
  ModelName* modelname_;
  WorldName* worldname_;
  ListWorldName* listworldname_;
  RequireKey* requirekey_;
  ListRequireKey* listrequirekey_;
  TrivialDef* trivialdef_;
  ListName* listname_;
  ListAgentName* listagentname_;
  ListModalityName* listmodalityname_;
  ListVariable* listvariable_;
}

%{
void yyerror(YYLTYPE *loc, yyscan_t scanner, YYSTYPE *result, const char *msg)
{
  fprintf(stderr, "error: %d,%d: %s at %s\n",
    loc->first_line, loc->first_column, msg, epddl_get_text(scanner));
}

int yyparse(yyscan_t scanner, YYSTYPE *result);

extern int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner);
%}

%token          _ERROR_
%token          _LPAREN            /* ( */
%token          _RPAREN            /* ) */
%token          _MINUS             /* - */
%token          _DCOLON            /* :: */
%token          _SYMB_8            /* :action */
%token          _SYMB_11           /* :action-type */
%token          _SYMB_2            /* :action-type-libraries */
%token          _SYMB_22           /* :agent-groups */
%token          _SYMB_21           /* :agents */
%token          _SYMB_52           /* :common-knowledge */
%token          _SYMB_42           /* :del */
%token          _SYMB_17           /* :designated */
%token          _SYMB_20           /* :domain */
%token          _SYMB_53           /* :dynamic-common-knowledge */
%token          _SYMB_44           /* :equality */
%token          _SYMB_18           /* :event */
%token          _SYMB_15           /* :events */
%token          _SYMB_46           /* :existential-formulae */
%token          _SYMB_14           /* :frame-of-reference */
%token          _SYMB_34           /* :goal */
%token          _SYMB_27           /* :init */
%token          _SYMB_54           /* :ma-star */
%token          _SYMB_57           /* :ma-star-announcement */
%token          _SYMB_58           /* :ma-star-finitary-theory */
%token          _SYMB_55           /* :ma-star-ontic */
%token          _SYMB_56           /* :ma-star-sensing */
%token          _SYMB_61           /* :maximum-modal-depth */
%token          _SYMB_60           /* :maximum-postconditions-depth */
%token          _SYMB_59           /* :maximum-preconditions-depth */
%token          _SYMB_50           /* :modal-postconditions */
%token          _SYMB_49           /* :modal-preconditions */
%token          _SYMB_6            /* :modalities */
%token          _SYMB_31           /* :model */
%token          _SYMB_28           /* :model-name */
%token          _SYMB_25           /* :objects */
%token          _SYMB_13           /* :observability-conditions */
%token          _SYMB_7            /* :observability-groups */
%token          _SYMB_51           /* :ontic-change */
%token          _SYMB_45           /* :parameter-lists */
%token          _SYMB_9            /* :parameters */
%token          _SYMB_19           /* :postconditions */
%token          _SYMB_12           /* :precondition */
%token          _SYMB_5            /* :predicates */
%token          _SYMB_16           /* :relations */
%token          _SYMB_3            /* :requirements */
%token          _SYMB_26           /* :static */
%token          _SYMB_4            /* :types */
%token          _SYMB_43           /* :typing */
%token          _SYMB_47           /* :universal-formulae */
%token          _SYMB_48           /* :universal-postconditions */
%token          _SYMB_33           /* :valuation */
%token          _SYMB_10           /* :where */
%token          _SYMB_32           /* :worlds */
%token          _LT                /* < */
%token          _EQ                /* = */
%token          _GT                /* > */
%token          _SYMB_39           /* ?_ */
%token          _KW_All            /* All */
%token          _LBRACK            /* [ */
%token          _RBRACK            /* ] */
%token          _KW_agent          /* agent */
%token          _KW_and            /* and */
%token          _KW_as             /* as */
%token          _KW_define         /* define */
%token          _KW_domain         /* domain */
%token          _KW_exists         /* exists */
%token          _KW_false          /* false */
%token          _KW_forall         /* forall */
%token          _KW_formula        /* formula */
%token          _KW_if             /* if */
%token          _KW_iff            /* iff */
%token          _KW_imply          /* imply */
%token          _KW_library        /* library */
%token          _KW_literal        /* literal */
%token          _KW_not            /* not */
%token          _KW_or             /* or */
%token          _KW_otherwise      /* otherwise */
%token          _KW_postcondition  /* postcondition */
%token          _KW_predicate      /* predicate */
%token          _SYMB_41           /* predicate-formula */
%token          _KW_problem        /* problem */
%token          _KW_set            /* set */
%token          _KW_true           /* true */
%token          _LBRACE            /* { */
%token          _RBRACE            /* } */
%token<_string> T_AgentName        /* AgentName */
%token<_string> T_ModalityName     /* ModalityName */
%token<_string> T_Name             /* Name */
%token<_string> T_Variable         /* Variable */
%token<_int>    _INTEGER_

%type <_name> Name
%type <_agentname> AgentName
%type <_modalityname> ModalityName
%type <_variable> Variable
%type <maindef_> MainDef
%type <domaindef_> DomainDef
%type <domainitemdef_> DomainItemDef
%type <listdomainitemdef_> ListDomainItemDef
%type <domainlibrariesnamedef_> DomainLibrariesNameDef
%type <requiredef_> RequireDef
%type <typesdef_> TypesDef
%type <predicatelistdef_> PredicateListDef
%type <predicatedef_> PredicateDef
%type <listpredicatedef_> ListPredicateDef
%type <modalitiesdef_> ModalitiesDef
%type <observabilitygroupsdef_> ObservabilityGroupsDef
%type <actiondef_> ActionDef
%type <actionparameterdef_> ActionParameterDef
%type <actionconditionsdef_> ActionConditionsDef
%type <actiontypesignaturedef_> ActionTypeSignatureDef
%type <actionpredef_> ActionPreDef
%type <actionobsdef_> ActionObsDef
%type <obsconditiondef_> ObsConditionDef
%type <listobsconditiondef_> ListObsConditionDef
%type <librarydef_> LibraryDef
%type <libraryitemdef_> LibraryItemDef
%type <listlibraryitemdef_> ListLibraryItemDef
%type <actiontypedef_> ActionTypeDef
%type <actiontypeparameterdef_> ActionTypeParameterDef
%type <actiontypeframedef_> ActionTypeFrameDef
%type <actiontypeeventsdef_> ActionTypeEventsDef
%type <actiontypereldef_> ActionTypeRelDef
%type <actiontypedesdef_> ActionTypeDesDef
%type <eventsignature_> EventSignature
%type <listeventsignature_> ListEventSignature
%type <actionrelations_> ActionRelations
%type <eventrelation_> EventRelation
%type <listeventrelation_> ListEventRelation
%type <eventnamepair_> EventNamePair
%type <listeventnamepair_> ListEventNamePair
%type <eventdef_> EventDef
%type <eventparameterdef_> EventParameterDef
%type <eventpredef_> EventPreDef
%type <eventpostdef_> EventPostDef
%type <eventpostconditions_> EventPostconditions
%type <postcondition_> Postcondition
%type <listpostcondition_> ListPostcondition
%type <literalpostcondition_> LiteralPostcondition
%type <listliteralpostcondition_> ListLiteralPostcondition
%type <problemdef_> ProblemDef
%type <problemitemdef_> ProblemItemDef
%type <listproblemitemdef_> ListProblemItemDef
%type <problemdomainnamedef_> ProblemDomainNameDef
%type <agentnamesdef_> AgentNamesDef
%type <agentgroupslistdef_> AgentGroupsListDef
%type <agentgroupdef_> AgentGroupDef
%type <listagentgroupdef_> ListAgentGroupDef
%type <objectnamesdef_> ObjectNamesDef
%type <staticpredlistdef_> StaticPredListDef
%type <staticpreddef_> StaticPredDef
%type <liststaticpreddef_> ListStaticPredDef
%type <initdef_> InitDef
%type <initialstatedescr_> InitialStateDescr
%type <ftheoryformula_> FTheoryFormula
%type <listftheoryformula_> ListFTheoryFormula
%type <kpredicateformula_> KPredicateFormula
%type <kwpredicateformula_> KWPredicateFormula
%type <notkwpredicateformula_> NotKWPredicateFormula
%type <initialmodeldef_> InitialModelDef
%type <modelworldsdef_> ModelWorldsDef
%type <modelreldef_> ModelRelDef
%type <modelvaldef_> ModelValDef
%type <modeldesdef_> ModelDesDef
%type <modelrelations_> ModelRelations
%type <modelvaluation_> ModelValuation
%type <worldrelation_> WorldRelation
%type <listworldrelation_> ListWorldRelation
%type <worldnamepair_> WorldNamePair
%type <listworldnamepair_> ListWorldNamePair
%type <worldvaluation_> WorldValuation
%type <listworldvaluation_> ListWorldValuation
%type <goaldef_> GoalDef
%type <formula_> Formula
%type <listformula_> ListFormula
%type <atomicformula_> AtomicFormula
%type <atomiceqformula_> AtomicEqFormula
%type <formulaorempty_> FormulaOrEmpty
%type <metaterm_> MetaTerm
%type <listmetaterm_> ListMetaTerm
%type <term_> Term
%type <listterm_> ListTerm
%type <groundterm_> GroundTerm
%type <listgroundterm_> ListGroundTerm
%type <modality_> Modality
%type <singlemodality_> SingleModality
%type <groupmodality_> GroupModality
%type <modalitylabel_> ModalityLabel
%type <knowswhether_> KnowsWhether
%type <literal_> Literal
%type <listliteral_> ListLiteral
%type <conditionformula_> ConditionFormula
%type <condition_> Condition
%type <listcondition_> ListCondition
%type <atomiccondition_> AtomicCondition
%type <predicateformula_> PredicateFormula
%type <listpredicateformula_> ListPredicateFormula
%type <genericname_> GenericName
%type <listgenericname_> ListGenericName
%type <typedidentlist_> TypedIdentList
%type <typedagentlist_> TypedAgentList
%type <typedvariablelist_> TypedVariableList
%type <predicatename_> PredicateName
%type <modalityagent_> ModalityAgent
%type <listmodalityagent_> ListModalityAgent
%type <modalityagentgroup_> ModalityAgentGroup
%type <agentgroupname_> AgentGroupName
%type <observingagentgroup_> ObservingAgentGroup
%type <listobservingagentgroup_> ListObservingAgentGroup
%type <observingagent_> ObservingAgent
%type <agentgroup_> AgentGroup
%type <allagents_> AllAgents
%type <anonvaragent_> AnonVarAgent
%type <parameter_> Parameter
%type <listparameter_> ListParameter
%type <parametervalue_> ParameterValue
%type <postparametervalue_> PostParameterValue
%type <listpostparametervalue_> ListPostParameterValue
%type <type_> Type
%type <reservedtype_> ReservedType
%type <domainname_> DomainName
%type <libraryname_> LibraryName
%type <listlibraryname_> ListLibraryName
%type <problemname_> ProblemName
%type <actionname_> ActionName
%type <actiontypename_> ActionTypeName
%type <eventname_> EventName
%type <listeventname_> ListEventName
%type <modelname_> ModelName
%type <worldname_> WorldName
%type <listworldname_> ListWorldName
%type <requirekey_> RequireKey
%type <listrequirekey_> ListRequireKey
%type <trivialdef_> TrivialDef
%type <listname_> ListName
%type <listagentname_> ListAgentName
%type <listmodalityname_> ListModalityName
%type <listvariable_> ListVariable

%start MainDef

%%

MainDef : DomainDef { $$ = new Domain($1); result->maindef_ = $$; }
  | LibraryDef { $$ = new ActionTypeLibrary($1); result->maindef_ = $$; }
  | ProblemDef { $$ = new Problem($1); result->maindef_ = $$; }
;
DomainDef : _LPAREN _KW_define _LPAREN _KW_domain DomainName _RPAREN ListDomainItemDef _RPAREN { $$ = new EPDDLDomain($5, $7); }
;
DomainItemDef : DomainLibrariesNameDef { $$ = new EPDDLDomLibrary($1); }
  | RequireDef { $$ = new EPDDLDomRequire($1); }
  | TypesDef { $$ = new EPDDLDomTypes($1); }
  | PredicateListDef { $$ = new EPDDLDomPredicates($1); }
  | ModalitiesDef { $$ = new EPDDLDomModalities($1); }
  | ObservabilityGroupsDef { $$ = new EPDDLDomObsGroups($1); }
  | ActionDef { $$ = new EPDDLDomAction($1); }
;
ListDomainItemDef : /* empty */ { $$ = new ListDomainItemDef(); }
  | ListDomainItemDef DomainItemDef { $1->push_back($2); $$ = $1; }
;
DomainLibrariesNameDef : _LPAREN _SYMB_2 ListLibraryName _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new EPDDLDomLibraryNames($3); }
;
RequireDef : _LPAREN _SYMB_3 ListRequireKey _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new EPDDLRequire($3); }
;
TypesDef : _LPAREN _SYMB_4 TypedIdentList _RPAREN { $$ = new EPDDLTypes($3); }
;
PredicateListDef : _LPAREN _SYMB_5 ListPredicateDef _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new EPDDLPredicateList($3); }
;
PredicateDef : _LPAREN PredicateName TypedVariableList _RPAREN { $$ = new EPDDLPredicateDef($2, $3); }
;
ListPredicateDef : PredicateDef { $$ = new ListPredicateDef(); $$->push_back($1); }
  | PredicateDef ListPredicateDef { $2->push_back($1); $$ = $2; }
;
ModalitiesDef : _LPAREN _SYMB_6 ListModalityName _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new EPDDLModalities($3); }
;
ObservabilityGroupsDef : _LPAREN _SYMB_7 ListObservingAgentGroup _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new EPDDLObsGroupsNames($3); }
;
ActionDef : _LPAREN _SYMB_8 ActionName ActionParameterDef ActionConditionsDef ActionTypeSignatureDef ActionPreDef ActionObsDef _RPAREN { $$ = new EPDDLAction($3, $4, $5, $6, $7, $8); }
;
ActionParameterDef : _SYMB_9 _LPAREN TypedVariableList _RPAREN { $$ = new ActionParam($3); }
;
ActionConditionsDef : _SYMB_10 ConditionFormula { $$ = new ActionCond($2); }
  | /* empty */ { $$ = new EmptyActionCond(); }
;
ActionTypeSignatureDef : _SYMB_11 _LPAREN ActionTypeName ListParameter _RPAREN { $$ = new ActionSignature($3, $4); }
;
ActionPreDef : _SYMB_12 FormulaOrEmpty { $$ = new ActionPre($2); }
;
ActionObsDef : _SYMB_13 ListObsConditionDef { std::reverse($2->begin(),$2->end()) ;$$ = new ActionObs($2); }
  | /* empty */ { $$ = new EmptyActionObs(); }
;
ObsConditionDef : _LPAREN ObservingAgent ObservingAgentGroup _RPAREN { $$ = new EmptyObsCond($2, $3); }
  | _LPAREN ObservingAgent ObservingAgentGroup _KW_if Formula _RPAREN { $$ = new ObsCond($2, $3, $5); }
  | _LPAREN _KW_otherwise ObservingAgent ObservingAgentGroup _RPAREN { $$ = new ObsOtherwiseCond($3, $4); }
;
ListObsConditionDef : ObsConditionDef { $$ = new ListObsConditionDef(); $$->push_back($1); }
  | ObsConditionDef ListObsConditionDef { $2->push_back($1); $$ = $2; }
;
LibraryDef : _LPAREN _KW_define _LPAREN _KW_library LibraryName _RPAREN ListLibraryItemDef _RPAREN { $$ = new EPDDLLibrary($5, $7); }
;
LibraryItemDef : RequireDef { $$ = new EPDDLLibRequire($1); }
  | ModalitiesDef { $$ = new EPDDLLibModalities($1); }
  | ObservabilityGroupsDef { $$ = new EPDDLLibObsGroups($1); }
  | ActionTypeDef { $$ = new EPDDLLibActionType($1); }
  | EventDef { $$ = new EPDDLLibEvent($1); }
;
ListLibraryItemDef : /* empty */ { $$ = new ListLibraryItemDef(); }
  | ListLibraryItemDef LibraryItemDef { $1->push_back($2); $$ = $1; }
;
ActionTypeDef : _LPAREN _SYMB_11 ActionTypeName ActionTypeParameterDef ActionTypeFrameDef ActionTypeEventsDef ActionTypeRelDef ActionTypeDesDef _RPAREN { $$ = new EPDDLActType($3, $4, $5, $6, $7, $8); }
;
ActionTypeParameterDef : _SYMB_9 _LPAREN TypedVariableList _RPAREN { $$ = new ActTypeParam($3); }
;
ActionTypeFrameDef : _SYMB_14 _LPAREN ListObservingAgentGroup _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new ActTypeFrame($3); }
  | /* empty */ { $$ = new EmptyActTypeFrame(); }
;
ActionTypeEventsDef : _SYMB_15 ListEventSignature { std::reverse($2->begin(),$2->end()) ;$$ = new ActTypeEvents($2); }
;
ActionTypeRelDef : _SYMB_16 ActionRelations { $$ = new ActTypeRel($2); }
;
ActionTypeDesDef : _SYMB_17 _LPAREN ListEventName _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new ActTypeDes($3); }
;
EventSignature : _LPAREN EventName ListParameter _RPAREN { $$ = new EventSign($2, $3); }
;
ListEventSignature : EventSignature { $$ = new ListEventSignature(); $$->push_back($1); }
  | EventSignature ListEventSignature { $2->push_back($1); $$ = $2; }
;
ActionRelations : ListEventRelation { std::reverse($1->begin(),$1->end()) ;$$ = new EventsActionRel($1); }
  | TrivialDef { $$ = new TrivialActionRel($1); }
;
EventRelation : _LPAREN AgentGroup ListEventNamePair _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new EventRel($2, $3); }
  | _LPAREN AgentGroup TrivialDef _RPAREN { $$ = new TrivialEventRel($2, $3); }
;
ListEventRelation : EventRelation { $$ = new ListEventRelation(); $$->push_back($1); }
  | EventRelation ListEventRelation { $2->push_back($1); $$ = $2; }
;
EventNamePair : _LPAREN EventName EventName _RPAREN { $$ = new EventPair($2, $3); }
;
ListEventNamePair : EventNamePair { $$ = new ListEventNamePair(); $$->push_back($1); }
  | EventNamePair ListEventNamePair { $2->push_back($1); $$ = $2; }
;
EventDef : _LPAREN _SYMB_18 EventName EventParameterDef EventPreDef EventPostDef _RPAREN { $$ = new EPDDLEvent($3, $4, $5, $6); }
;
EventParameterDef : _SYMB_9 _LPAREN TypedVariableList _RPAREN { $$ = new EventParam($3); }
;
EventPreDef : _SYMB_12 FormulaOrEmpty { $$ = new EventPre($2); }
;
EventPostDef : _SYMB_19 EventPostconditions { $$ = new EventPost($2); }
  | /* empty */ { $$ = new EmptyEventPost(); }
;
EventPostconditions : ListPostcondition { std::reverse($1->begin(),$1->end()) ;$$ = new Postconditions($1); }
  | TrivialDef { $$ = new TrivialPostconditions($1); }
;
Postcondition : _LPAREN _KW_forall _LPAREN TypedVariableList _RPAREN ListLiteralPostcondition _RPAREN { std::reverse($6->begin(),$6->end()) ;$$ = new ForallPostcondition($4, $6); }
  | LiteralPostcondition { $$ = new SinglePostcondition($1); }
  | _LPAREN Variable _RPAREN { $$ = new VarPostcondition($2); }
;
ListPostcondition : Postcondition { $$ = new ListPostcondition(); $$->push_back($1); }
  | Postcondition ListPostcondition { $2->push_back($1); $$ = $2; }
;
LiteralPostcondition : _LPAREN _KW_set Literal _KW_iff FormulaOrEmpty _RPAREN { $$ = new LiteralPost($3, $5); }
  | _LPAREN _KW_set Literal _RPAREN { $$ = new TrivialLiteralPost($3); }
;
ListLiteralPostcondition : LiteralPostcondition { $$ = new ListLiteralPostcondition(); $$->push_back($1); }
  | LiteralPostcondition ListLiteralPostcondition { $2->push_back($1); $$ = $2; }
;
ProblemDef : _LPAREN _KW_define _LPAREN _KW_problem ProblemName _RPAREN ListProblemItemDef _RPAREN { $$ = new EPDDLProblem($5, $7); }
;
ProblemItemDef : ProblemDomainNameDef { $$ = new EPDDLProbDomain($1); }
  | RequireDef { $$ = new EPDDLProbRequire($1); }
  | ModalitiesDef { $$ = new EPDDLProbModalities($1); }
  | AgentNamesDef { $$ = new EPDDLProbAgents($1); }
  | AgentGroupsListDef { $$ = new EPDDLProbAgentGroups($1); }
  | ObjectNamesDef { $$ = new EPDDLProbObjects($1); }
  | StaticPredListDef { $$ = new EPDDLProbStaticPred($1); }
  | InitDef { $$ = new EPDDLProbInit($1); }
  | InitialModelDef { $$ = new EPDDLProbInitModel($1); }
  | GoalDef { $$ = new EPDDLProbGoal($1); }
;
ListProblemItemDef : /* empty */ { $$ = new ListProblemItemDef(); }
  | ListProblemItemDef ProblemItemDef { $1->push_back($2); $$ = $1; }
;
ProblemDomainNameDef : _LPAREN _SYMB_20 DomainName _RPAREN { $$ = new EPDDLProbDomainName($3); }
;
AgentNamesDef : _LPAREN _SYMB_21 TypedAgentList _RPAREN { $$ = new EPDDLAgentNames($3); }
;
AgentGroupsListDef : _LPAREN _SYMB_22 ListAgentGroupDef _RPAREN { $$ = new EPDDLAgentGroupsList($3); }
;
AgentGroupDef : _LPAREN _LBRACE AgentName ListAgentName _RBRACE _KW_as AgentGroupName _RPAREN { std::reverse($4->begin(),$4->end()) ;$$ = new EPDDLAgentGroupDef($3, $4, $7); }
;
ListAgentGroupDef : /* empty */ { $$ = new ListAgentGroupDef(); }
  | ListAgentGroupDef AgentGroupDef { $1->push_back($2); $$ = $1; }
;
ObjectNamesDef : _LPAREN _SYMB_25 TypedIdentList _RPAREN { $$ = new EPDDLObjectNames($3); }
;
StaticPredListDef : _LPAREN _SYMB_26 ListStaticPredDef _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new EPDDLStaticPredList($3); }
;
StaticPredDef : _LPAREN PredicateName ListGenericName _RPAREN { $$ = new EPDDLStaticPredDef($2, $3); }
;
ListStaticPredDef : StaticPredDef { $$ = new ListStaticPredDef(); $$->push_back($1); }
  | StaticPredDef ListStaticPredDef { $2->push_back($1); $$ = $2; }
;
InitDef : _LPAREN _SYMB_27 InitialStateDescr _RPAREN { $$ = new EPDDLInitialState($3); }
;
InitialStateDescr : ListFTheoryFormula { std::reverse($1->begin(),$1->end()) ;$$ = new FinitaryTheoryDescr($1); }
  | _LPAREN _SYMB_28 ModelName _RPAREN { $$ = new InitialModelDescr($3); }
;
FTheoryFormula : PredicateFormula { $$ = new FTheoryPredForm($1); }
  | _LBRACK AllAgents _RBRACK PredicateFormula { $$ = new FTheoryCKPredForm($2, $4); }
  | _LBRACK AllAgents _RBRACK KPredicateFormula { $$ = new FTheoryCKKPredForm($2, $4); }
  | _LBRACK AllAgents _RBRACK KWPredicateFormula { $$ = new FTheoryCKOrKPredForm($2, $4); }
  | _LBRACK AllAgents _RBRACK NotKWPredicateFormula { $$ = new FTheoryCKAndKPredForm($2, $4); }
  | _LPAREN FTheoryFormula _RPAREN { $$ = $2; }
;
ListFTheoryFormula : FTheoryFormula { $$ = new ListFTheoryFormula(); $$->push_back($1); }
  | FTheoryFormula ListFTheoryFormula { $2->push_back($1); $$ = $2; }
;
KPredicateFormula : _LBRACK AgentName _RBRACK PredicateFormula { $$ = new KPredFormula($2, $4); }
  | _LPAREN KPredicateFormula _RPAREN { $$ = $2; }
;
KWPredicateFormula : KnowsWhether PredicateFormula { $$ = new KWPredFormula($1, $2); }
  | _LPAREN KWPredicateFormula _RPAREN { $$ = $2; }
;
NotKWPredicateFormula : _LPAREN _KW_not KnowsWhether PredicateFormula _RPAREN { $$ = new NotKWPredFormula($3, $4); }
  | _LPAREN NotKWPredicateFormula _RPAREN { $$ = $2; }
;
InitialModelDef : _LPAREN _SYMB_31 ModelName ModelWorldsDef ModelRelDef ModelValDef ModelDesDef _RPAREN { $$ = new EPDDLInitialModel($3, $4, $5, $6, $7); }
;
ModelWorldsDef : _SYMB_32 _LPAREN ListWorldName _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new ModelWorlds($3); }
;
ModelRelDef : _SYMB_16 ModelRelations { $$ = new ModelRel($2); }
;
ModelValDef : _SYMB_33 ModelValuation { $$ = new ModelVal($2); }
;
ModelDesDef : _SYMB_17 _LPAREN ListWorldName _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new ModelDes($3); }
;
ModelRelations : ListWorldRelation { std::reverse($1->begin(),$1->end()) ;$$ = new WorldsModelRel($1); }
  | TrivialDef { $$ = new TrivialModelRel($1); }
;
ModelValuation : ListWorldValuation { std::reverse($1->begin(),$1->end()) ;$$ = new WorldsModelVal($1); }
  | TrivialDef { $$ = new TrivialModelVal($1); }
;
WorldRelation : _LPAREN AgentGroup ListWorldNamePair _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new WorldRel($2, $3); }
  | _LPAREN AgentGroup TrivialDef _RPAREN { $$ = new TrivialWorldRel($2, $3); }
;
ListWorldRelation : WorldRelation { $$ = new ListWorldRelation(); $$->push_back($1); }
  | WorldRelation ListWorldRelation { $2->push_back($1); $$ = $2; }
;
WorldNamePair : _LPAREN WorldName WorldName _RPAREN { $$ = new WorldPair($2, $3); }
;
ListWorldNamePair : WorldNamePair { $$ = new ListWorldNamePair(); $$->push_back($1); }
  | WorldNamePair ListWorldNamePair { $2->push_back($1); $$ = $2; }
;
WorldValuation : _LPAREN WorldName _LBRACK ListLiteral _RBRACK _RPAREN { $$ = new WorldVal($2, $4); }
;
ListWorldValuation : WorldValuation { $$ = new ListWorldValuation(); $$->push_back($1); }
  | WorldValuation ListWorldValuation { $2->push_back($1); $$ = $2; }
;
GoalDef : _LPAREN _SYMB_34 Formula _RPAREN { $$ = new EPDDLGoals($3); }
;
Formula : _LPAREN _KW_imply Formula Formula _RPAREN { $$ = new ImplyFormula($3, $4); }
  | _LPAREN _KW_or Formula ListFormula _RPAREN { std::reverse($4->begin(),$4->end()) ;$$ = new OrFormula($3, $4); }
  | _LPAREN _KW_and Formula ListFormula _RPAREN { std::reverse($4->begin(),$4->end()) ;$$ = new AndFormula($3, $4); }
  | _LPAREN _KW_not Formula _RPAREN { $$ = new NotFormula($3); }
  | _LPAREN _KW_exists _LPAREN TypedVariableList _RPAREN Formula _RPAREN { $$ = new ExistsFormula($4, $6); }
  | _LPAREN _KW_forall _LPAREN TypedVariableList _RPAREN Formula _RPAREN { $$ = new ForAllFormula($4, $6); }
  | Modality Formula { $$ = new ModalFormula($1, $2); }
  | _LPAREN Variable _RPAREN { $$ = new VarFormula($2); }
  | AtomicFormula { $$ = new AtmFormula($1); }
  | AtomicEqFormula { $$ = new AtmEqFormula($1); }
  | _KW_true { $$ = new TrueFormula(); }
  | _KW_false { $$ = new FalseFormula(); }
  | _LPAREN Formula _RPAREN { $$ = $2; }
;
ListFormula : Formula { $$ = new ListFormula(); $$->push_back($1); }
  | Formula ListFormula { $2->push_back($1); $$ = $2; }
;
AtomicFormula : _LPAREN PredicateName ListMetaTerm _RPAREN { $$ = new Predicate($2, $3); }
;
AtomicEqFormula : _LPAREN _EQ Term Term _RPAREN { $$ = new EqFormula($3, $4); }
;
FormulaOrEmpty : Formula { $$ = new NonTrivialFormula($1); }
  | TrivialDef { $$ = new TrivialFormula($1); }
;
MetaTerm : Term { $$ = new EPDDLMetaTerm($1); }
  | AnonVarAgent { $$ = new EPDDLMetaTermAnonVar($1); }
;
ListMetaTerm : /* empty */ { $$ = new ListMetaTerm(); }
  | ListMetaTerm MetaTerm { $1->push_back($2); $$ = $1; }
;
Term : GroundTerm { $$ = new EPDDLGroundTerm($1); }
  | Variable { $$ = new EPDDLTermVar($1); }
;
ListTerm : /* empty */ { $$ = new ListTerm(); }
  | ListTerm Term { $1->push_back($2); $$ = $1; }
;
GroundTerm : Name { $$ = new EPDDLGroundTermName($1); }
  | AgentName { $$ = new EPDDLGroundTermAgName($1); }
;
ListGroundTerm : /* empty */ { $$ = new ListGroundTerm(); }
  | ListGroundTerm GroundTerm { $1->push_back($2); $$ = $1; }
;
Modality : SingleModality { $$ = new EPDDLLabeledMod($1); }
  | GroupModality { $$ = new EPDDLLabeledGroupMod($1); }
;
SingleModality : _LBRACK ModalityLabel ModalityAgent _RBRACK { $$ = new LabBoxMod($2, $3); }
  | _LT ModalityLabel ModalityAgent _GT { $$ = new LabDiamondMod($2, $3); }
;
GroupModality : _LBRACK ModalityLabel ModalityAgentGroup _RBRACK { $$ = new LabBoxGroupMod($2, $3); }
  | _LT ModalityLabel ModalityAgentGroup _GT { $$ = new LabDiamondGroupMod($2, $3); }
;
ModalityLabel : ModalityName { $$ = new ModLabel($1); }
  | /* empty */ { $$ = new EmptyModLabel(); }
;
KnowsWhether : _LBRACK ModalityName AgentName _RBRACK { $$ = new KnowsWhetherMod($2, $3); }
;
Literal : AtomicFormula { $$ = new PosLiteral($1); }
  | _LPAREN _KW_not AtomicFormula _RPAREN { $$ = new NegLiteral($3); }
;
ListLiteral : /* empty */ { $$ = new ListLiteral(); }
  | ListLiteral Literal { $1->push_back($2); $$ = $1; }
;
ConditionFormula : _LPAREN _KW_and Condition ListCondition _RPAREN { std::reverse($4->begin(),$4->end()) ;$$ = new AndCondFomula($3, $4); }
  | Condition { $$ = new CondFomula($1); }
;
Condition : AtomicCondition { $$ = new AtmCond($1); }
  | _LPAREN _KW_not AtomicCondition _RPAREN { $$ = new NotAtmCond($3); }
;
ListCondition : Condition { $$ = new ListCondition(); $$->push_back($1); }
  | Condition ListCondition { $2->push_back($1); $$ = $2; }
;
AtomicCondition : _LPAREN PredicateName ListTerm _RPAREN { $$ = new AtmCondPredicate($2, $3); }
  | _LPAREN _EQ Term Term _RPAREN { $$ = new AtmCondEqFormula($3, $4); }
;
PredicateFormula : _LPAREN _KW_imply PredicateFormula PredicateFormula _RPAREN { $$ = new ImplyPredFormula($3, $4); }
  | _LPAREN _KW_or PredicateFormula ListPredicateFormula _RPAREN { std::reverse($4->begin(),$4->end()) ;$$ = new OrPredFormula($3, $4); }
  | _LPAREN _KW_and PredicateFormula ListPredicateFormula _RPAREN { std::reverse($4->begin(),$4->end()) ;$$ = new AndPredFormula($3, $4); }
  | _LPAREN _KW_not PredicateFormula _RPAREN { $$ = new NotPredFormula($3); }
  | _LPAREN PredicateName ListGroundTerm _RPAREN { $$ = new AtmPredFormula($2, $3); }
;
ListPredicateFormula : PredicateFormula { $$ = new ListPredicateFormula(); $$->push_back($1); }
  | PredicateFormula ListPredicateFormula { $2->push_back($1); $$ = $2; }
;
GenericName : Name { $$ = new EPDDLGenericNameObj($1); }
  | AgentName { $$ = new EPDDLGenericNameAg($1); }
;
ListGenericName : /* empty */ { $$ = new ListGenericName(); }
  | ListGenericName GenericName { $1->push_back($2); $$ = $1; }
;
TypedIdentList : ListName { std::reverse($1->begin(),$1->end()) ;$$ = new IdList($1); }
  | Name ListName _MINUS Type TypedIdentList { std::reverse($2->begin(),$2->end()) ;$$ = new TypedIdList($1, $2, $4, $5); }
;
TypedAgentList : ListAgentName { std::reverse($1->begin(),$1->end()) ;$$ = new AgList($1); }
  | AgentName ListAgentName _MINUS Type TypedAgentList { std::reverse($2->begin(),$2->end()) ;$$ = new TypedAgList($1, $2, $4, $5); }
;
TypedVariableList : ListVariable { std::reverse($1->begin(),$1->end()) ;$$ = new VarList($1); }
  | Variable ListVariable _MINUS Type TypedVariableList { std::reverse($2->begin(),$2->end()) ;$$ = new TypedVarList($1, $2, $4, $5); }
;
PredicateName : Name { $$ = new EPDDLPredicate($1); }
;
ModalityAgent : AgentName { $$ = new EPDDLModAgent($1); }
  | Variable { $$ = new EPDDLModVarAgent($1); }
  | AnonVarAgent { $$ = new EPDDLModAnonVarAgent($1); }
  | AllAgents { $$ = new EPDDLModAllAgents($1); }
;
ListModalityAgent : ModalityAgent { $$ = new ListModalityAgent(); $$->push_back($1); }
  | ModalityAgent ListModalityAgent { $2->push_back($1); $$ = $2; }
;
ModalityAgentGroup : ModalityAgent ListModalityAgent { std::reverse($2->begin(),$2->end()) ;$$ = new EPDDLModAgList($1, $2); }
;
AgentGroupName : AgentName { $$ = new EPDDLSingleAgentGroup($1); }
  | AllAgents { $$ = new EPDDLAllAgentsGroup($1); }
;
ObservingAgentGroup : AgentName { $$ = new EPDDLObsAgentGroup($1); }
;
ListObservingAgentGroup : ObservingAgentGroup { $$ = new ListObservingAgentGroup(); $$->push_back($1); }
  | ObservingAgentGroup ListObservingAgentGroup { $2->push_back($1); $$ = $2; }
;
ObservingAgent : AgentName { $$ = new EPDDLObsAgent($1); }
  | AllAgents { $$ = new EPDDLObsAllAgents($1); }
  | Variable { $$ = new EPDDLObsVarAgent($1); }
  | AnonVarAgent { $$ = new EPDDLObsAnonVarAgent($1); }
;
AgentGroup : AgentGroupName { $$ = new EPDDLAgentGroup($1); }
  | _LBRACE AgentName ListAgentName _RBRACE { std::reverse($3->begin(),$3->end()) ;$$ = new EPDDLAgentNameGroup($2, $3); }
;
AllAgents : _KW_All { $$ = new EPDDLAllAgents(); }
;
AnonVarAgent : _SYMB_39 { $$ = new EPDDLAnonVarAgent(); }
;
Parameter : _LPAREN Variable _DCOLON ParameterValue _RPAREN { $$ = new EPDDLParam($2, $4); }
;
ListParameter : /* empty */ { $$ = new ListParameter(); }
  | ListParameter Parameter { $1->push_back($2); $$ = $1; }
;
ParameterValue : Term { $$ = new EPDDLTermParam($1); }
  | Formula { $$ = new EPDDLFormulaParam($1); }
  | ListPostParameterValue { std::reverse($1->begin(),$1->end()) ;$$ = new EPDDLPostParam($1); }
;
PostParameterValue : _LPAREN _KW_forall _LPAREN TypedVariableList _RPAREN ListLiteralPostcondition _RPAREN { std::reverse($6->begin(),$6->end()) ;$$ = new PostParamForall($4, $6); }
  | LiteralPostcondition { $$ = new PostParamLiteral($1); }
;
ListPostParameterValue : PostParameterValue { $$ = new ListPostParameterValue(); $$->push_back($1); }
  | PostParameterValue ListPostParameterValue { $2->push_back($1); $$ = $2; }
;
Type : Name { $$ = new EPDDLTypeName($1); }
  | ReservedType { $$ = new EPDDLResType($1); }
;
ReservedType : _KW_agent { $$ = new ResAgentType(); }
  | _KW_predicate { $$ = new PredicateType(); }
  | _KW_literal { $$ = new LiteralType(); }
  | _SYMB_41 { $$ = new PredFormulaType(); }
  | _KW_formula { $$ = new FormulaType(); }
  | _KW_postcondition { $$ = new PostconditionType(); }
;
DomainName : Name { $$ = new EPDDLDomainName($1); }
;
LibraryName : Name { $$ = new EPDDLLibraryName($1); }
;
ListLibraryName : LibraryName { $$ = new ListLibraryName(); $$->push_back($1); }
  | LibraryName ListLibraryName { $2->push_back($1); $$ = $2; }
;
ProblemName : Name { $$ = new EPDDLProblemName($1); }
;
ActionName : Name { $$ = new EPDDLActionName($1); }
;
ActionTypeName : Name { $$ = new EPDDLActTypeName($1); }
;
EventName : Name { $$ = new EPDDLEventName($1); }
;
ListEventName : EventName { $$ = new ListEventName(); $$->push_back($1); }
  | EventName ListEventName { $2->push_back($1); $$ = $2; }
;
ModelName : Name { $$ = new EPDDLModelName($1); }
;
WorldName : Name { $$ = new EPDDLWorldName($1); }
;
ListWorldName : WorldName { $$ = new ListWorldName(); $$->push_back($1); }
  | WorldName ListWorldName { $2->push_back($1); $$ = $2; }
;
RequireKey : _SYMB_42 { $$ = new EPDDLReqDel(); }
  | _SYMB_43 { $$ = new EPDDLReqTyping(); }
  | _SYMB_44 { $$ = new EPDDLReqEquality(); }
  | _SYMB_45 { $$ = new EPDDLReqParamList(); }
  | _SYMB_46 { $$ = new EPDDLReqExiForm(); }
  | _SYMB_47 { $$ = new EPDDLReqUniForm(); }
  | _SYMB_48 { $$ = new EPDDLReqUniPost(); }
  | _SYMB_49 { $$ = new EPDDLReqModPre(); }
  | _SYMB_50 { $$ = new EPDDLReqModPost(); }
  | _SYMB_6 { $$ = new EPDDLReqModalities(); }
  | _SYMB_51 { $$ = new EPDDLReqOnticChange(); }
  | _SYMB_52 { $$ = new EPDDLReqCK(); }
  | _SYMB_53 { $$ = new EPDDLReqDynCK(); }
  | _SYMB_54 { $$ = new EPDDLReqMAStar(); }
  | _SYMB_55 { $$ = new EPDDLReqOntic(); }
  | _SYMB_56 { $$ = new EPDDLReqSensing(); }
  | _SYMB_57 { $$ = new EPDDLReqAnnouncement(); }
  | _SYMB_58 { $$ = new EPDDLReqFTheory(); }
  | _LPAREN _SYMB_59 _INTEGER_ _RPAREN { $$ = new EPDDLReqMaxPreDepth($3); }
  | _LPAREN _SYMB_60 _INTEGER_ _RPAREN { $$ = new EPDDLReqMaxPostDepth($3); }
  | _LPAREN _SYMB_61 _INTEGER_ _RPAREN { $$ = new EPDDLReqMaxDepth($3); }
;
ListRequireKey : RequireKey { $$ = new ListRequireKey(); $$->push_back($1); }
  | RequireKey ListRequireKey { $2->push_back($1); $$ = $2; }
;
TrivialDef : _LPAREN _RPAREN { $$ = new EPDDLTrivialDef(); }
;
ListName : /* empty */ { $$ = new ListName(); }
  | Name ListName { $2->push_back($1); $$ = $2; }
;
ListAgentName : /* empty */ { $$ = new ListAgentName(); }
  | AgentName ListAgentName { $2->push_back($1); $$ = $2; }
;
ListModalityName : /* empty */ { $$ = new ListModalityName(); }
  | ModalityName ListModalityName { $2->push_back($1); $$ = $2; }
;
ListVariable : /* empty */ { $$ = new ListVariable(); }
  | Variable ListVariable { $2->push_back($1); $$ = $2; }
;
Name : T_Name { $$ = new Name($1, @$.first_line); }
;
AgentName : T_AgentName { $$ = new AgentName($1, @$.first_line); }
;
ModalityName : T_ModalityName { $$ = new ModalityName($1, @$.first_line); }
;
Variable : T_Variable { $$ = new Variable($1, @$.first_line); }
;

%%


/* Entrypoint: parse MainDef* from file. */
MainDef* pMainDef(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = epddl__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  epddl_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.maindef_;
  }
}

/* Entrypoint: parse MainDef* from string. */
MainDef* psMainDef(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = epddl__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = epddl__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  epddl__delete_buffer(buf, scanner);
  epddl_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.maindef_;
  }
}



