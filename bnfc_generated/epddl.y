/* -*- c++ -*- File generated by the BNF Converter (bnfc 2.9.4). */

/* Parser definition to be used with Bison. */

/* Generate header file for lexer. */
%defines "Bison.H"

/* Reentrant parser */
%pure_parser
  /* From Bison 2.3b (2008): %define api.pure full */
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }

/* Turn on line/column tracking in the epddl_lloc structure: */
%locations

/* Argument to the parser to be filled with the parsed tree. */
%parse-param { YYSTYPE *result }

%{
/* Begin C preamble code */

#include <algorithm> /* for std::reverse */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Absyn.H"

#define YYMAXDEPTH 10000000

/* The type yyscan_t is defined by flex, but we need it in the parser already. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE epddl__scan_string(const char *str, yyscan_t scanner);
extern void epddl__delete_buffer(YY_BUFFER_STATE buf, yyscan_t scanner);

extern void epddl_lex_destroy(yyscan_t scanner);
extern char* epddl_get_text(yyscan_t scanner);

extern yyscan_t epddl__initialize_lexer(FILE * inp);

/* End C preamble code */
%}

%union
{
  int    _int;
  char   _char;
  double _double;
  char*  _string;
  Name* _name;
  AgentName* _agentname;
  ModalityName* _modalityname;
  Variable* _variable;
  MainDef* maindef_;
  DomainDef* domaindef_;
  DomainItemDef* domainitemdef_;
  ListDomainItemDef* listdomainitemdef_;
  DomainLibrariesNameDef* domainlibrariesnamedef_;
  RequireDef* requiredef_;
  TypesDef* typesdef_;
  PredicateListDef* predicatelistdef_;
  PredicateDef* predicatedef_;
  ListPredicateDef* listpredicatedef_;
  ModalitiesDef* modalitiesdef_;
  ActionDef* actiondef_;
  ParametersDef* parametersdef_;
  ActionConditionDef* actionconditiondef_;
  ActionTypeSignatureDef* actiontypesignaturedef_;
  ActionPreDef* actionpredef_;
  ActionObsDef* actionobsdef_;
  ObsConditionDef* obsconditiondef_;
  ListObsConditionDef* listobsconditiondef_;
  ObsCondition* obscondition_;
  ListObsCondition* listobscondition_;
  LibraryDef* librarydef_;
  LibraryItemDef* libraryitemdef_;
  ListLibraryItemDef* listlibraryitemdef_;
  ObservabilityGroupsDef* observabilitygroupsdef_;
  ActionTypeDef* actiontypedef_;
  ActionTypeGroupsDef* actiontypegroupsdef_;
  ActionTypeEventsDef* actiontypeeventsdef_;
  EventSignature* eventsignature_;
  ListEventSignature* listeventsignature_;
  ActionTypeRelDef* actiontypereldef_;
  ActionRelations* actionrelations_;
  EventRelation* eventrelation_;
  ListEventRelation* listeventrelation_;
  EventNamePair* eventnamepair_;
  ListEventNamePair* listeventnamepair_;
  ActionTypeDesignDef* actiontypedesigndef_;
  EventDef* eventdef_;
  EventPreDef* eventpredef_;
  EventPostDef* eventpostdef_;
  PostconditionBlock* postconditionblock_;
  Postcondition* postcondition_;
  ListPostcondition* listpostcondition_;
  SimplePostcondition* simplepostcondition_;
  ListSimplePostcondition* listsimplepostcondition_;
  ProblemDef* problemdef_;
  ProblemItemDef* problemitemdef_;
  ListProblemItemDef* listproblemitemdef_;
  ProblemDomainNameDef* problemdomainnamedef_;
  AgentNamesDef* agentnamesdef_;
  AgentGroupsListDef* agentgroupslistdef_;
  AgentGroupDef* agentgroupdef_;
  ListAgentGroupDef* listagentgroupdef_;
  ObjectNamesDef* objectnamesdef_;
  StaticPredListDef* staticpredlistdef_;
  StaticPredDef* staticpreddef_;
  ListStaticPredDef* liststaticpreddef_;
  InitDef* initdef_;
  InitialStateDescr* initialstatedescr_;
  FTheoryFormula* ftheoryformula_;
  ListFTheoryFormula* listftheoryformula_;
  SimpleFTheoryFormula* simpleftheoryformula_;
  StateDef* statedef_;
  StateWorldsDef* stateworldsdef_;
  StateRelDef* statereldef_;
  StateRelations* staterelations_;
  WorldRelation* worldrelation_;
  ListWorldRelation* listworldrelation_;
  WorldNamePair* worldnamepair_;
  ListWorldNamePair* listworldnamepair_;
  StateValDef* statevaldef_;
  StateValuation* statevaluation_;
  WorldValuation* worldvaluation_;
  ListWorldValuation* listworldvaluation_;
  StateDesignDef* statedesigndef_;
  GoalDef* goaldef_;
  Formula* formula_;
  ListFormula* listformula_;
  AtomicFormula* atomicformula_;
  Predicate* predicate_;
  AtomicEqFormula* atomiceqformula_;
  FormulaOrEmpty* formulaorempty_;
  Term* term_;
  ListTerm* listterm_;
  GroundTerm* groundterm_;
  ListGroundTerm* listgroundterm_;
  Modality* modality_;
  SingleModality* singlemodality_;
  GroupModality* groupmodality_;
  ModalityLabel* modalitylabel_;
  KnowsWhether* knowswhether_;
  Literal* literal_;
  ListLiteral* listliteral_;
  ConditionFormula* conditionformula_;
  Condition* condition_;
  ListCondition* listcondition_;
  AtomicCondition* atomiccondition_;
  PredicateFormula* predicateformula_;
  ListPredicateFormula* listpredicateformula_;
  GenericName* genericname_;
  ListGenericName* listgenericname_;
  TypedIdentList* typedidentlist_;
  TypedAgentList* typedagentlist_;
  TypedVariableList* typedvariablelist_;
  PredicateName* predicatename_;
  ModalityAgent* modalityagent_;
  ListModalityAgent* listmodalityagent_;
  ModalityAgentGroup* modalityagentgroup_;
  AgentGroupName* agentgroupname_;
  ObservingAgentGroup* observingagentgroup_;
  ListObservingAgentGroup* listobservingagentgroup_;
  ObservingAgent* observingagent_;
  AgentGroup* agentgroup_;
  AllAgents* allagents_;
  Parameter* parameter_;
  ListParameter* listparameter_;
  Expression* expression_;
  Type* type_;
  ReservedType* reservedtype_;
  DomainName* domainname_;
  LibraryName* libraryname_;
  ListLibraryName* listlibraryname_;
  ProblemName* problemname_;
  ActionName* actionname_;
  ActionTypeName* actiontypename_;
  EventName* eventname_;
  ListEventName* listeventname_;
  StateName* statename_;
  WorldName* worldname_;
  ListWorldName* listworldname_;
  RequirementKey* requirementkey_;
  ListRequirementKey* listrequirementkey_;
  TrivialDef* trivialdef_;
  ListName* listname_;
  ListAgentName* listagentname_;
  ListModalityName* listmodalityname_;
  ListVariable* listvariable_;
}

%{
void yyerror(YYLTYPE *loc, yyscan_t scanner, YYSTYPE *result, const char *msg)
{
  fprintf(stderr, "error: %d,%d: %s at %s\n",
    loc->first_line, loc->first_column, msg, epddl_get_text(scanner));
}

int yyparse(yyscan_t scanner, YYSTYPE *result);

extern int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner);
%}

%token          _ERROR_
%token          _LPAREN            /* ( */
%token          _RPAREN            /* ) */
%token          _MINUS             /* - */
%token          _COLON             /* : */
%token          _DCOLON            /* :: */
%token          _SYMB_7            /* :action */
%token          _SYMB_10           /* :action-type */
%token          _SYMB_2            /* :action-type-libraries */
%token          _SYMB_23           /* :agent-groups */
%token          _SYMB_22           /* :agents */
%token          _SYMB_50           /* :common-knowledge */
%token          _SYMB_41           /* :del */
%token          _SYMB_17           /* :designated */
%token          _SYMB_21           /* :domain */
%token          _SYMB_51           /* :dynamic-common-knowledge */
%token          _SYMB_43           /* :equality */
%token          _SYMB_18           /* :event */
%token          _SYMB_15           /* :events */
%token          _SYMB_44           /* :existential-formulae */
%token          _SYMB_52           /* :finitary-S5-theory */
%token          _SYMB_35           /* :goal */
%token          _SYMB_28           /* :init */
%token          _SYMB_55           /* :maximum-modal-depth */
%token          _SYMB_54           /* :maximum-postconditions-depth */
%token          _SYMB_53           /* :maximum-preconditions-depth */
%token          _SYMB_48           /* :modal-postconditions */
%token          _SYMB_47           /* :modal-preconditions */
%token          _SYMB_6            /* :modalities */
%token          _SYMB_26           /* :objects */
%token          _SYMB_12           /* :observability-conditions */
%token          _SYMB_14           /* :observability-groups */
%token          _SYMB_49           /* :ontic-change */
%token          _SYMB_8            /* :parameters */
%token          _SYMB_19           /* :postconditions */
%token          _SYMB_11           /* :precondition */
%token          _SYMB_5            /* :predicates */
%token          _SYMB_16           /* :relations */
%token          _SYMB_3            /* :requirements */
%token          _SYMB_32           /* :state */
%token          _SYMB_29           /* :state-name */
%token          _SYMB_27           /* :static */
%token          _SYMB_4            /* :types */
%token          _SYMB_42           /* :typing */
%token          _SYMB_45           /* :universal-formulae */
%token          _SYMB_46           /* :universal-postconditions */
%token          _SYMB_34           /* :valuation */
%token          _SYMB_9            /* :where */
%token          _SYMB_33           /* :worlds */
%token          _LT                /* < */
%token          _EQ                /* = */
%token          _GT                /* > */
%token          _KW_All            /* All */
%token          _LBRACK            /* [ */
%token          _RBRACK            /* ] */
%token          _KW_agent          /* agent */
%token          _KW_and            /* and */
%token          _KW_as             /* as */
%token          _KW_define         /* define */
%token          _KW_domain         /* domain */
%token          _KW_exists         /* exists */
%token          _KW_false          /* false */
%token          _KW_forall         /* forall */
%token          _KW_formula        /* formula */
%token          _KW_if             /* if */
%token          _KW_iff            /* iff */
%token          _KW_imply          /* imply */
%token          _KW_library        /* library */
%token          _KW_literal        /* literal */
%token          _KW_not            /* not */
%token          _KW_or             /* or */
%token          _KW_otherwise      /* otherwise */
%token          _KW_postcondition  /* postcondition */
%token          _KW_predicate      /* predicate */
%token          _SYMB_40           /* predicate-formula */
%token          _KW_problem        /* problem */
%token          _KW_true           /* true */
%token          _KW_when           /* when */
%token          _LBRACE            /* { */
%token          _RBRACE            /* } */
%token<_string> T_AgentName        /* AgentName */
%token<_string> T_ModalityName     /* ModalityName */
%token<_string> T_Name             /* Name */
%token<_string> T_Variable         /* Variable */
%token<_int>    _INTEGER_

%type <_name> Name
%type <_agentname> AgentName
%type <_modalityname> ModalityName
%type <_variable> Variable
%type <maindef_> MainDef
%type <domaindef_> DomainDef
%type <domainitemdef_> DomainItemDef
%type <listdomainitemdef_> ListDomainItemDef
%type <domainlibrariesnamedef_> DomainLibrariesNameDef
%type <requiredef_> RequireDef
%type <typesdef_> TypesDef
%type <predicatelistdef_> PredicateListDef
%type <predicatedef_> PredicateDef
%type <listpredicatedef_> ListPredicateDef
%type <modalitiesdef_> ModalitiesDef
%type <actiondef_> ActionDef
%type <parametersdef_> ParametersDef
%type <actionconditiondef_> ActionConditionDef
%type <actiontypesignaturedef_> ActionTypeSignatureDef
%type <actionpredef_> ActionPreDef
%type <actionobsdef_> ActionObsDef
%type <obsconditiondef_> ObsConditionDef
%type <listobsconditiondef_> ListObsConditionDef
%type <obscondition_> ObsCondition
%type <listobscondition_> ListObsCondition
%type <librarydef_> LibraryDef
%type <libraryitemdef_> LibraryItemDef
%type <listlibraryitemdef_> ListLibraryItemDef
%type <observabilitygroupsdef_> ObservabilityGroupsDef
%type <actiontypedef_> ActionTypeDef
%type <actiontypegroupsdef_> ActionTypeGroupsDef
%type <actiontypeeventsdef_> ActionTypeEventsDef
%type <eventsignature_> EventSignature
%type <listeventsignature_> ListEventSignature
%type <actiontypereldef_> ActionTypeRelDef
%type <actionrelations_> ActionRelations
%type <eventrelation_> EventRelation
%type <listeventrelation_> ListEventRelation
%type <eventnamepair_> EventNamePair
%type <listeventnamepair_> ListEventNamePair
%type <actiontypedesigndef_> ActionTypeDesignDef
%type <eventdef_> EventDef
%type <eventpredef_> EventPreDef
%type <eventpostdef_> EventPostDef
%type <postconditionblock_> PostconditionBlock
%type <postcondition_> Postcondition
%type <listpostcondition_> ListPostcondition
%type <simplepostcondition_> SimplePostcondition
%type <listsimplepostcondition_> ListSimplePostcondition
%type <problemdef_> ProblemDef
%type <problemitemdef_> ProblemItemDef
%type <listproblemitemdef_> ListProblemItemDef
%type <problemdomainnamedef_> ProblemDomainNameDef
%type <agentnamesdef_> AgentNamesDef
%type <agentgroupslistdef_> AgentGroupsListDef
%type <agentgroupdef_> AgentGroupDef
%type <listagentgroupdef_> ListAgentGroupDef
%type <objectnamesdef_> ObjectNamesDef
%type <staticpredlistdef_> StaticPredListDef
%type <staticpreddef_> StaticPredDef
%type <liststaticpreddef_> ListStaticPredDef
%type <initdef_> InitDef
%type <initialstatedescr_> InitialStateDescr
%type <ftheoryformula_> FTheoryFormula
%type <listftheoryformula_> ListFTheoryFormula
%type <simpleftheoryformula_> SimpleFTheoryFormula
%type <statedef_> StateDef
%type <stateworldsdef_> StateWorldsDef
%type <statereldef_> StateRelDef
%type <staterelations_> StateRelations
%type <worldrelation_> WorldRelation
%type <listworldrelation_> ListWorldRelation
%type <worldnamepair_> WorldNamePair
%type <listworldnamepair_> ListWorldNamePair
%type <statevaldef_> StateValDef
%type <statevaluation_> StateValuation
%type <worldvaluation_> WorldValuation
%type <listworldvaluation_> ListWorldValuation
%type <statedesigndef_> StateDesignDef
%type <goaldef_> GoalDef
%type <formula_> Formula
%type <listformula_> ListFormula
%type <atomicformula_> AtomicFormula
%type <predicate_> Predicate
%type <atomiceqformula_> AtomicEqFormula
%type <formulaorempty_> FormulaOrEmpty
%type <term_> Term
%type <listterm_> ListTerm
%type <groundterm_> GroundTerm
%type <listgroundterm_> ListGroundTerm
%type <modality_> Modality
%type <singlemodality_> SingleModality
%type <groupmodality_> GroupModality
%type <modalitylabel_> ModalityLabel
%type <knowswhether_> KnowsWhether
%type <literal_> Literal
%type <listliteral_> ListLiteral
%type <conditionformula_> ConditionFormula
%type <condition_> Condition
%type <listcondition_> ListCondition
%type <atomiccondition_> AtomicCondition
%type <predicateformula_> PredicateFormula
%type <listpredicateformula_> ListPredicateFormula
%type <genericname_> GenericName
%type <listgenericname_> ListGenericName
%type <typedidentlist_> TypedIdentList
%type <typedagentlist_> TypedAgentList
%type <typedvariablelist_> TypedVariableList
%type <predicatename_> PredicateName
%type <modalityagent_> ModalityAgent
%type <listmodalityagent_> ListModalityAgent
%type <modalityagentgroup_> ModalityAgentGroup
%type <agentgroupname_> AgentGroupName
%type <observingagentgroup_> ObservingAgentGroup
%type <listobservingagentgroup_> ListObservingAgentGroup
%type <observingagent_> ObservingAgent
%type <agentgroup_> AgentGroup
%type <allagents_> AllAgents
%type <parameter_> Parameter
%type <listparameter_> ListParameter
%type <expression_> Expression
%type <type_> Type
%type <reservedtype_> ReservedType
%type <domainname_> DomainName
%type <libraryname_> LibraryName
%type <listlibraryname_> ListLibraryName
%type <problemname_> ProblemName
%type <actionname_> ActionName
%type <actiontypename_> ActionTypeName
%type <eventname_> EventName
%type <listeventname_> ListEventName
%type <statename_> StateName
%type <worldname_> WorldName
%type <listworldname_> ListWorldName
%type <requirementkey_> RequirementKey
%type <listrequirementkey_> ListRequirementKey
%type <trivialdef_> TrivialDef
%type <listname_> ListName
%type <listagentname_> ListAgentName
%type <listmodalityname_> ListModalityName
%type <listvariable_> ListVariable

%start MainDef

%%

MainDef : DomainDef { $$ = new Domain($1); result->maindef_ = $$; }
  | LibraryDef { $$ = new ActionTypeLibrary($1); result->maindef_ = $$; }
  | ProblemDef { $$ = new Problem($1); result->maindef_ = $$; }
;
DomainDef : _LPAREN _KW_define _LPAREN _KW_domain DomainName _RPAREN ListDomainItemDef _RPAREN { $$ = new EPDDLDomain($5, $7); }
;
DomainItemDef : DomainLibrariesNameDef { $$ = new EPDDLDomLibrary($1); }
  | RequireDef { $$ = new EPDDLDomRequire($1); }
  | TypesDef { $$ = new EPDDLDomTypes($1); }
  | PredicateListDef { $$ = new EPDDLDomPredicates($1); }
  | ModalitiesDef { $$ = new EPDDLDomModalities($1); }
  | ActionDef { $$ = new EPDDLDomAction($1); }
;
ListDomainItemDef : /* empty */ { $$ = new ListDomainItemDef(); }
  | ListDomainItemDef DomainItemDef { $1->push_back($2); $$ = $1; }
;
DomainLibrariesNameDef : _LPAREN _SYMB_2 ListLibraryName _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new EPDDLDomLibraryNames($3); }
;
RequireDef : _LPAREN _SYMB_3 ListRequirementKey _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new EPDDLRequire($3); }
;
TypesDef : _LPAREN _SYMB_4 TypedIdentList _RPAREN { $$ = new EPDDLTypes($3); }
;
PredicateListDef : _LPAREN _SYMB_5 ListPredicateDef _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new EPDDLPredicateList($3); }
;
PredicateDef : _LPAREN PredicateName TypedVariableList _RPAREN { $$ = new EPDDLPredicateDef($2, $3); }
;
ListPredicateDef : PredicateDef { $$ = new ListPredicateDef(); $$->push_back($1); }
  | PredicateDef ListPredicateDef { $2->push_back($1); $$ = $2; }
;
ModalitiesDef : _LPAREN _SYMB_6 ListModalityName _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new EPDDLModalities($3); }
;
ActionDef : _LPAREN _SYMB_7 ActionName ParametersDef ActionConditionDef ActionTypeSignatureDef ActionPreDef ActionObsDef _RPAREN { $$ = new EPDDLAction($3, $4, $5, $6, $7, $8); }
;
ParametersDef : _SYMB_8 _LPAREN TypedVariableList _RPAREN { $$ = new Parameters($3); }
;
ActionConditionDef : _SYMB_9 ConditionFormula { $$ = new ActionCond($2); }
  | /* empty */ { $$ = new EmptyActionCond(); }
;
ActionTypeSignatureDef : _SYMB_10 _LPAREN ActionTypeName ListParameter _RPAREN { $$ = new ActionSignature($3, $4); }
;
ActionPreDef : _SYMB_11 FormulaOrEmpty { $$ = new ActionPre($2); }
;
ActionObsDef : _SYMB_12 ListObsConditionDef { std::reverse($2->begin(),$2->end()) ;$$ = new ActionObs($2); }
  | /* empty */ { $$ = new EmptyActionObs(); }
;
ObsConditionDef : _LPAREN _KW_forall _LPAREN Variable _MINUS Type _RPAREN ListObsCondition _RPAREN { std::reverse($8->begin(),$8->end()) ;$$ = new UniversalObsCond($4, $6, $8); }
  | ObsCondition { $$ = new ObsCond($1); }
;
ListObsConditionDef : ObsConditionDef { $$ = new ListObsConditionDef(); $$->push_back($1); }
  | ObsConditionDef ListObsConditionDef { $2->push_back($1); $$ = $2; }
;
ObsCondition : _LPAREN ObservingAgent ObservingAgentGroup _RPAREN { $$ = new TrivialObsCond($2, $3); }
  | _LPAREN _KW_if Formula ObservingAgent ObservingAgentGroup _RPAREN { $$ = new IfObsCond($3, $4, $5); }
  | _LPAREN _KW_otherwise ObservingAgent ObservingAgentGroup _RPAREN { $$ = new OtherwiseObsCond($3, $4); }
;
ListObsCondition : ObsCondition { $$ = new ListObsCondition(); $$->push_back($1); }
  | ObsCondition ListObsCondition { $2->push_back($1); $$ = $2; }
;
LibraryDef : _LPAREN _KW_define _LPAREN _KW_library LibraryName _RPAREN ListLibraryItemDef _RPAREN { $$ = new EPDDLLibrary($5, $7); }
;
LibraryItemDef : RequireDef { $$ = new EPDDLLibRequire($1); }
  | ModalitiesDef { $$ = new EPDDLLibModalities($1); }
  | ObservabilityGroupsDef { $$ = new EPDDLLibObsGroups($1); }
  | ActionTypeDef { $$ = new EPDDLLibActionType($1); }
  | EventDef { $$ = new EPDDLLibEvent($1); }
;
ListLibraryItemDef : /* empty */ { $$ = new ListLibraryItemDef(); }
  | ListLibraryItemDef LibraryItemDef { $1->push_back($2); $$ = $1; }
;
ObservabilityGroupsDef : _LPAREN _SYMB_14 ListObservingAgentGroup _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new EPDDLObsGroupsNames($3); }
;
ActionTypeDef : _LPAREN _SYMB_10 ActionTypeName ParametersDef ActionTypeGroupsDef ActionTypeEventsDef ActionTypeRelDef ActionTypeDesignDef _RPAREN { $$ = new EPDDLActType($3, $4, $5, $6, $7, $8); }
;
ActionTypeGroupsDef : _SYMB_14 _LPAREN ListObservingAgentGroup _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new ActTypeGroups($3); }
  | /* empty */ { $$ = new EmptyActTypeGroups(); }
;
ActionTypeEventsDef : _SYMB_15 ListEventSignature { std::reverse($2->begin(),$2->end()) ;$$ = new ActTypeEvents($2); }
;
EventSignature : _LPAREN EventName ListParameter _RPAREN { $$ = new EventSign($2, $3); }
;
ListEventSignature : EventSignature { $$ = new ListEventSignature(); $$->push_back($1); }
  | EventSignature ListEventSignature { $2->push_back($1); $$ = $2; }
;
ActionTypeRelDef : _SYMB_16 ActionRelations { $$ = new ActTypeRel($2); }
;
ActionRelations : ListEventRelation { std::reverse($1->begin(),$1->end()) ;$$ = new EventsActionRel($1); }
  | TrivialDef { $$ = new TrivialActionRel($1); }
;
EventRelation : _LPAREN AgentGroup ListEventNamePair _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new EventRel($2, $3); }
  | _LPAREN AgentGroup TrivialDef _RPAREN { $$ = new TrivialEventRel($2, $3); }
;
ListEventRelation : EventRelation { $$ = new ListEventRelation(); $$->push_back($1); }
  | EventRelation ListEventRelation { $2->push_back($1); $$ = $2; }
;
EventNamePair : _LPAREN EventName EventName _RPAREN { $$ = new EventPair($2, $3); }
;
ListEventNamePair : EventNamePair { $$ = new ListEventNamePair(); $$->push_back($1); }
  | EventNamePair ListEventNamePair { $2->push_back($1); $$ = $2; }
;
ActionTypeDesignDef : _SYMB_17 _LPAREN ListEventName _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new ActTypeDesign($3); }
;
EventDef : _LPAREN _SYMB_18 EventName ParametersDef EventPreDef EventPostDef _RPAREN { $$ = new EPDDLEvent($3, $4, $5, $6); }
;
EventPreDef : _SYMB_11 FormulaOrEmpty { $$ = new EventPre($2); }
;
EventPostDef : _SYMB_19 PostconditionBlock { $$ = new EventPost($2); }
  | /* empty */ { $$ = new EmptyEventPost(); }
;
PostconditionBlock : _LPAREN _COLON ListPostcondition _RPAREN { $$ = new PostAnonBlock($3); }
;
Postcondition : SimplePostcondition { $$ = new SimplePost($1); }
  | _LPAREN _KW_forall _LPAREN TypedVariableList _RPAREN ListSimplePostcondition _RPAREN { std::reverse($6->begin(),$6->end()) ;$$ = new UniversalPost($4, $6); }
  | _LPAREN Variable _RPAREN { $$ = new VarPost($2); }
;
ListPostcondition : /* empty */ { $$ = new ListPostcondition(); }
  | ListPostcondition Postcondition { $1->push_back($2); $$ = $1; }
;
SimplePostcondition : _LPAREN _KW_iff FormulaOrEmpty Literal _RPAREN { $$ = new IffPost($3, $4); }
  | _LPAREN _KW_when FormulaOrEmpty Literal _RPAREN { $$ = new WhenPost($3, $4); }
  | Literal { $$ = new TrivialLiteralPost($1); }
;
ListSimplePostcondition : SimplePostcondition { $$ = new ListSimplePostcondition(); $$->push_back($1); }
  | SimplePostcondition ListSimplePostcondition { $2->push_back($1); $$ = $2; }
;
ProblemDef : _LPAREN _KW_define _LPAREN _KW_problem ProblemName _RPAREN ListProblemItemDef _RPAREN { $$ = new EPDDLProblem($5, $7); }
;
ProblemItemDef : ProblemDomainNameDef { $$ = new EPDDLProbDomain($1); }
  | RequireDef { $$ = new EPDDLProbRequire($1); }
  | ModalitiesDef { $$ = new EPDDLProbModalities($1); }
  | AgentNamesDef { $$ = new EPDDLProbAgents($1); }
  | AgentGroupsListDef { $$ = new EPDDLProbAgentGroups($1); }
  | ObjectNamesDef { $$ = new EPDDLProbObjects($1); }
  | StaticPredListDef { $$ = new EPDDLProbStaticPred($1); }
  | InitDef { $$ = new EPDDLProbInit($1); }
  | StateDef { $$ = new EPDDLProbInitState($1); }
  | GoalDef { $$ = new EPDDLProbGoal($1); }
;
ListProblemItemDef : /* empty */ { $$ = new ListProblemItemDef(); }
  | ListProblemItemDef ProblemItemDef { $1->push_back($2); $$ = $1; }
;
ProblemDomainNameDef : _LPAREN _SYMB_21 DomainName _RPAREN { $$ = new EPDDLProbDomainName($3); }
;
AgentNamesDef : _LPAREN _SYMB_22 TypedAgentList _RPAREN { $$ = new EPDDLAgentNames($3); }
;
AgentGroupsListDef : _LPAREN _SYMB_23 ListAgentGroupDef _RPAREN { $$ = new EPDDLAgentGroupsList($3); }
;
AgentGroupDef : _LPAREN _LBRACE AgentName ListAgentName _RBRACE _KW_as AgentGroupName _RPAREN { std::reverse($4->begin(),$4->end()) ;$$ = new EPDDLAgentGroupDef($3, $4, $7); }
;
ListAgentGroupDef : /* empty */ { $$ = new ListAgentGroupDef(); }
  | ListAgentGroupDef AgentGroupDef { $1->push_back($2); $$ = $1; }
;
ObjectNamesDef : _LPAREN _SYMB_26 TypedIdentList _RPAREN { $$ = new EPDDLObjectNames($3); }
;
StaticPredListDef : _LPAREN _SYMB_27 ListStaticPredDef _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new EPDDLStaticPredList($3); }
;
StaticPredDef : _LPAREN PredicateName ListGenericName _RPAREN { $$ = new EPDDLStaticPredDef($2, $3); }
;
ListStaticPredDef : StaticPredDef { $$ = new ListStaticPredDef(); $$->push_back($1); }
  | StaticPredDef ListStaticPredDef { $2->push_back($1); $$ = $2; }
;
InitDef : _LPAREN _SYMB_28 InitialStateDescr _RPAREN { $$ = new EPDDLInitialState($3); }
;
InitialStateDescr : ListFTheoryFormula { std::reverse($1->begin(),$1->end()) ;$$ = new FinitaryTheoryDescr($1); }
  | _LPAREN _SYMB_29 StateName _RPAREN { $$ = new InitStateNameDescr($3); }
;
FTheoryFormula : SimpleFTheoryFormula { $$ = new SimpleFTheoryForm($1); }
  | _LPAREN _KW_forall _LPAREN TypedVariableList _RPAREN SimpleFTheoryFormula _RPAREN { $$ = new UniversalFTheoryForm($4, $6); }
;
ListFTheoryFormula : FTheoryFormula { $$ = new ListFTheoryFormula(); $$->push_back($1); }
  | FTheoryFormula ListFTheoryFormula { $2->push_back($1); $$ = $2; }
;
SimpleFTheoryFormula : PredicateFormula { $$ = new FTheoryPredForm($1); }
  | _LBRACK AllAgents _RBRACK PredicateFormula { $$ = new FTheoryCKPredForm($2, $4); }
  | _LBRACK AllAgents _RBRACK _LBRACK AgentName _RBRACK PredicateFormula { $$ = new FTheoryCKKPredForm($2, $5, $7); }
  | _LBRACK AllAgents _RBRACK KnowsWhether PredicateFormula { $$ = new FTheoryCKOrKPredForm($2, $4, $5); }
  | _LBRACK AllAgents _RBRACK _LPAREN _KW_not KnowsWhether PredicateFormula _RPAREN { $$ = new FTheoryCKAndKPredForm($2, $6, $7); }
;
StateDef : _LPAREN _SYMB_32 StateName StateWorldsDef StateRelDef StateValDef StateDesignDef _RPAREN { $$ = new EPDDLExplicitState($3, $4, $5, $6, $7); }
;
StateWorldsDef : _SYMB_33 _LPAREN ListWorldName _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new StateWorlds($3); }
;
StateRelDef : _SYMB_16 StateRelations { $$ = new StateRel($2); }
;
StateRelations : ListWorldRelation { std::reverse($1->begin(),$1->end()) ;$$ = new WorldsStateRel($1); }
  | TrivialDef { $$ = new TrivialStateRel($1); }
;
WorldRelation : _LPAREN AgentGroup ListWorldNamePair _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new WorldRel($2, $3); }
  | _LPAREN AgentGroup TrivialDef _RPAREN { $$ = new TrivialWorldRel($2, $3); }
;
ListWorldRelation : WorldRelation { $$ = new ListWorldRelation(); $$->push_back($1); }
  | WorldRelation ListWorldRelation { $2->push_back($1); $$ = $2; }
;
WorldNamePair : _LPAREN WorldName WorldName _RPAREN { $$ = new WorldPair($2, $3); }
;
ListWorldNamePair : WorldNamePair { $$ = new ListWorldNamePair(); $$->push_back($1); }
  | WorldNamePair ListWorldNamePair { $2->push_back($1); $$ = $2; }
;
StateValDef : _SYMB_34 StateValuation { $$ = new StateVal($2); }
;
StateValuation : ListWorldValuation { std::reverse($1->begin(),$1->end()) ;$$ = new WorldsStateVal($1); }
  | TrivialDef { $$ = new TrivialStateVal($1); }
;
WorldValuation : _LPAREN WorldName _LBRACK ListLiteral _RBRACK _RPAREN { $$ = new WorldVal($2, $4); }
;
ListWorldValuation : WorldValuation { $$ = new ListWorldValuation(); $$->push_back($1); }
  | WorldValuation ListWorldValuation { $2->push_back($1); $$ = $2; }
;
StateDesignDef : _SYMB_17 _LPAREN ListWorldName _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new StateDesign($3); }
;
GoalDef : _LPAREN _SYMB_35 Formula _RPAREN { $$ = new EPDDLGoals($3); }
;
Formula : _LPAREN _KW_imply Formula Formula _RPAREN { $$ = new ImplyFormula($3, $4); }
  | _LPAREN _KW_or Formula ListFormula _RPAREN { std::reverse($4->begin(),$4->end()) ;$$ = new OrFormula($3, $4); }
  | _LPAREN _KW_and Formula ListFormula _RPAREN { std::reverse($4->begin(),$4->end()) ;$$ = new AndFormula($3, $4); }
  | _LPAREN _KW_not Formula _RPAREN { $$ = new NotFormula($3); }
  | _LPAREN _KW_exists _LPAREN TypedVariableList _RPAREN Formula _RPAREN { $$ = new ExistsFormula($4, $6); }
  | _LPAREN _KW_forall _LPAREN TypedVariableList _RPAREN Formula _RPAREN { $$ = new ForAllFormula($4, $6); }
  | Modality Formula { $$ = new ModalFormula($1, $2); }
  | _LPAREN Modality Formula _RPAREN { $$ = new ModalFormulaPar($2, $3); }
  | AtomicFormula { $$ = new AtmFormula($1); }
  | AtomicEqFormula { $$ = new AtmEqFormula($1); }
  | _KW_true { $$ = new TrueFormula(); }
  | _KW_false { $$ = new FalseFormula(); }
;
ListFormula : Formula { $$ = new ListFormula(); $$->push_back($1); }
  | Formula ListFormula { $2->push_back($1); $$ = $2; }
;
AtomicFormula : Predicate { $$ = new GroundAtmForm($1); }
  | _LPAREN Variable _RPAREN { $$ = new VarAtmForm($2); }
;
Predicate : _LPAREN PredicateName ListTerm _RPAREN { $$ = new PredicateAtmForm($2, $3); }
;
AtomicEqFormula : _LPAREN _EQ Term Term _RPAREN { $$ = new EqFormula($3, $4); }
;
FormulaOrEmpty : Formula { $$ = new NonTrivialFormula($1); }
  | TrivialDef { $$ = new TrivialFormula($1); }
;
Term : GroundTerm { $$ = new EPDDLGroundTerm($1); }
  | Variable { $$ = new EPDDLTermVar($1); }
;
ListTerm : /* empty */ { $$ = new ListTerm(); }
  | ListTerm Term { $1->push_back($2); $$ = $1; }
;
GroundTerm : Name { $$ = new EPDDLGroundTermName($1); }
  | AgentName { $$ = new EPDDLGroundTermAgName($1); }
;
ListGroundTerm : /* empty */ { $$ = new ListGroundTerm(); }
  | ListGroundTerm GroundTerm { $1->push_back($2); $$ = $1; }
;
Modality : SingleModality { $$ = new EPDDLLabeledMod($1); }
  | GroupModality { $$ = new EPDDLLabeledGroupMod($1); }
;
SingleModality : _LBRACK ModalityLabel ModalityAgent _RBRACK { $$ = new LabBoxMod($2, $3); }
  | _LT ModalityLabel ModalityAgent _GT { $$ = new LabDiamondMod($2, $3); }
;
GroupModality : _LBRACK ModalityLabel ModalityAgentGroup _RBRACK { $$ = new LabBoxGroupMod($2, $3); }
  | _LT ModalityLabel ModalityAgentGroup _GT { $$ = new LabDiamondGroupMod($2, $3); }
;
ModalityLabel : ModalityName { $$ = new ModLabel($1); }
  | /* empty */ { $$ = new EmptyModLabel(); }
;
KnowsWhether : _LBRACK ModalityName AgentName _RBRACK { $$ = new KnowsWhetherMod($2, $3); }
;
Literal : Predicate { $$ = new PosLiteral($1); }
  | _LPAREN _KW_not Predicate _RPAREN { $$ = new NegLiteral($3); }
;
ListLiteral : /* empty */ { $$ = new ListLiteral(); }
  | ListLiteral Literal { $1->push_back($2); $$ = $1; }
;
ConditionFormula : _LPAREN _KW_and Condition ListCondition _RPAREN { std::reverse($4->begin(),$4->end()) ;$$ = new AndCondFomula($3, $4); }
  | Condition { $$ = new CondFomula($1); }
;
Condition : AtomicCondition { $$ = new AtmCond($1); }
  | _LPAREN _KW_not AtomicCondition _RPAREN { $$ = new NotAtmCond($3); }
;
ListCondition : Condition { $$ = new ListCondition(); $$->push_back($1); }
  | Condition ListCondition { $2->push_back($1); $$ = $2; }
;
AtomicCondition : _LPAREN PredicateName ListTerm _RPAREN { $$ = new AtmCondPredicate($2, $3); }
  | _LPAREN _EQ Term Term _RPAREN { $$ = new AtmCondEqFormula($3, $4); }
;
PredicateFormula : _LPAREN _KW_imply PredicateFormula PredicateFormula _RPAREN { $$ = new ImplyPredFormula($3, $4); }
  | _LPAREN _KW_or PredicateFormula ListPredicateFormula _RPAREN { std::reverse($4->begin(),$4->end()) ;$$ = new OrPredFormula($3, $4); }
  | _LPAREN _KW_and PredicateFormula ListPredicateFormula _RPAREN { std::reverse($4->begin(),$4->end()) ;$$ = new AndPredFormula($3, $4); }
  | _LPAREN _KW_not PredicateFormula _RPAREN { $$ = new NotPredFormula($3); }
  | _LPAREN PredicateName ListGroundTerm _RPAREN { $$ = new AtmPredFormula($2, $3); }
;
ListPredicateFormula : PredicateFormula { $$ = new ListPredicateFormula(); $$->push_back($1); }
  | PredicateFormula ListPredicateFormula { $2->push_back($1); $$ = $2; }
;
GenericName : Name { $$ = new EPDDLGenericNameObj($1); }
  | AgentName { $$ = new EPDDLGenericNameAg($1); }
;
ListGenericName : /* empty */ { $$ = new ListGenericName(); }
  | ListGenericName GenericName { $1->push_back($2); $$ = $1; }
;
TypedIdentList : ListName { std::reverse($1->begin(),$1->end()) ;$$ = new IdList($1); }
  | Name ListName _MINUS Type TypedIdentList { std::reverse($2->begin(),$2->end()) ;$$ = new TypedIdList($1, $2, $4, $5); }
;
TypedAgentList : ListAgentName { std::reverse($1->begin(),$1->end()) ;$$ = new AgList($1); }
  | AgentName ListAgentName _MINUS Type TypedAgentList { std::reverse($2->begin(),$2->end()) ;$$ = new TypedAgList($1, $2, $4, $5); }
;
TypedVariableList : ListVariable { std::reverse($1->begin(),$1->end()) ;$$ = new VarList($1); }
  | Variable ListVariable _MINUS Type TypedVariableList { std::reverse($2->begin(),$2->end()) ;$$ = new TypedVarList($1, $2, $4, $5); }
;
PredicateName : Name { $$ = new EPDDLPredicate($1); }
;
ModalityAgent : AgentName { $$ = new EPDDLModAgent($1); }
  | Variable { $$ = new EPDDLModVarAgent($1); }
  | AllAgents { $$ = new EPDDLModAllAgents($1); }
;
ListModalityAgent : ModalityAgent { $$ = new ListModalityAgent(); $$->push_back($1); }
  | ModalityAgent ListModalityAgent { $2->push_back($1); $$ = $2; }
;
ModalityAgentGroup : ModalityAgent ListModalityAgent { std::reverse($2->begin(),$2->end()) ;$$ = new EPDDLModAgList($1, $2); }
;
AgentGroupName : AgentName { $$ = new EPDDLSingleAgentGroup($1); }
  | AllAgents { $$ = new EPDDLAllAgentsGroup($1); }
;
ObservingAgentGroup : AgentName { $$ = new EPDDLObsAgentGroup($1); }
;
ListObservingAgentGroup : ObservingAgentGroup { $$ = new ListObservingAgentGroup(); $$->push_back($1); }
  | ObservingAgentGroup ListObservingAgentGroup { $2->push_back($1); $$ = $2; }
;
ObservingAgent : AgentName { $$ = new EPDDLObsAgent($1); }
  | AllAgents { $$ = new EPDDLObsAllAgents($1); }
  | Variable { $$ = new EPDDLObsVarAgent($1); }
;
AgentGroup : AgentGroupName { $$ = new EPDDLAgentGroup($1); }
  | _LBRACE AgentName ListAgentName _RBRACE { std::reverse($3->begin(),$3->end()) ;$$ = new EPDDLAgentNameGroup($2, $3); }
;
AllAgents : _KW_All { $$ = new EPDDLAllAgents(); }
;
Parameter : _LPAREN Variable _DCOLON Expression _RPAREN { $$ = new EPDDLParam($2, $4); }
;
ListParameter : /* empty */ { $$ = new ListParameter(); }
  | ListParameter Parameter { $1->push_back($2); $$ = $1; }
;
Expression : Term { $$ = new EPDDLTermExpr($1); }
  | Formula { $$ = new EPDDLFormulaExpr($1); }
  | PostconditionBlock { $$ = new EPDDLPostExpr($1); }
;
Type : Name { $$ = new EPDDLTypeName($1); }
  | ReservedType { $$ = new EPDDLResType($1); }
;
ReservedType : _KW_agent { $$ = new ResAgentType(); }
  | _KW_predicate { $$ = new PredicateType(); }
  | _KW_literal { $$ = new LiteralType(); }
  | _SYMB_40 { $$ = new PredFormulaType(); }
  | _KW_formula { $$ = new FormulaType(); }
  | _KW_postcondition { $$ = new PostconditionType(); }
;
DomainName : Name { $$ = new EPDDLDomainName($1); }
;
LibraryName : Name { $$ = new EPDDLLibraryName($1); }
;
ListLibraryName : LibraryName { $$ = new ListLibraryName(); $$->push_back($1); }
  | LibraryName ListLibraryName { $2->push_back($1); $$ = $2; }
;
ProblemName : Name { $$ = new EPDDLProblemName($1); }
;
ActionName : Name { $$ = new EPDDLActionName($1); }
;
ActionTypeName : Name { $$ = new EPDDLActTypeName($1); }
;
EventName : Name { $$ = new EPDDLEventName($1); }
;
ListEventName : EventName { $$ = new ListEventName(); $$->push_back($1); }
  | EventName ListEventName { $2->push_back($1); $$ = $2; }
;
StateName : Name { $$ = new EPDDLStateName($1); }
;
WorldName : Name { $$ = new EPDDLWorldName($1); }
;
ListWorldName : WorldName { $$ = new ListWorldName(); $$->push_back($1); }
  | WorldName ListWorldName { $2->push_back($1); $$ = $2; }
;
RequirementKey : _SYMB_41 { $$ = new EPDDLReqDel(); }
  | _SYMB_42 { $$ = new EPDDLReqTyping(); }
  | _SYMB_43 { $$ = new EPDDLReqEquality(); }
  | _SYMB_44 { $$ = new EPDDLReqExiForm(); }
  | _SYMB_45 { $$ = new EPDDLReqUniForm(); }
  | _SYMB_46 { $$ = new EPDDLReqUniPost(); }
  | _SYMB_47 { $$ = new EPDDLReqModPre(); }
  | _SYMB_48 { $$ = new EPDDLReqModPost(); }
  | _SYMB_6 { $$ = new EPDDLReqModalities(); }
  | _SYMB_49 { $$ = new EPDDLReqOnticChange(); }
  | _SYMB_50 { $$ = new EPDDLReqCK(); }
  | _SYMB_51 { $$ = new EPDDLReqDynCK(); }
  | _SYMB_52 { $$ = new EPDDLReqFTheory(); }
  | _LPAREN _SYMB_53 _INTEGER_ _RPAREN { $$ = new EPDDLReqMaxPreDepth($3); }
  | _LPAREN _SYMB_54 _INTEGER_ _RPAREN { $$ = new EPDDLReqMaxPostDepth($3); }
  | _LPAREN _SYMB_55 _INTEGER_ _RPAREN { $$ = new EPDDLReqMaxDepth($3); }
;
ListRequirementKey : RequirementKey { $$ = new ListRequirementKey(); $$->push_back($1); }
  | RequirementKey ListRequirementKey { $2->push_back($1); $$ = $2; }
;
TrivialDef : _LPAREN _RPAREN { $$ = new EPDDLTrivialDef(); }
;
ListName : /* empty */ { $$ = new ListName(); }
  | Name ListName { $2->push_back($1); $$ = $2; }
;
ListAgentName : /* empty */ { $$ = new ListAgentName(); }
  | AgentName ListAgentName { $2->push_back($1); $$ = $2; }
;
ListModalityName : /* empty */ { $$ = new ListModalityName(); }
  | ModalityName ListModalityName { $2->push_back($1); $$ = $2; }
;
ListVariable : /* empty */ { $$ = new ListVariable(); }
  | Variable ListVariable { $2->push_back($1); $$ = $2; }
;
Name : T_Name { $$ = new Name($1, @$.first_line); }
;
AgentName : T_AgentName { $$ = new AgentName($1, @$.first_line); }
;
ModalityName : T_ModalityName { $$ = new ModalityName($1, @$.first_line); }
;
Variable : T_Variable { $$ = new Variable($1, @$.first_line); }
;

%%


/* Entrypoint: parse MainDef* from file. */
MainDef* pMainDef(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = epddl__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  epddl_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.maindef_;
  }
}

/* Entrypoint: parse MainDef* from string. */
MainDef* psMainDef(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = epddl__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = epddl__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  epddl__delete_buffer(buf, scanner);
  epddl_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.maindef_;
  }
}



