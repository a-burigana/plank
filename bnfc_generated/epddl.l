/* -*- c++ -*- File generated by the BNF Converter (bnfc 2.9.4). */

/* Lexer definition for use with FLex */

%option noyywrap noinput nounput
%option reentrant bison-bridge bison-locations

%{
#include "Absyn.H"
#include "Bison.H"

#define initialize_lexer epddl__initialize_lexer

static void update_loc(YYLTYPE* loc, char* text)
{
  loc->first_line = loc->last_line;
  loc->first_column = loc->last_column;
  int i = 0;
  for (; text[i] != '\0'; ++i) {
      if (text[i] == '\n') {
          ++loc->last_line;
          loc->last_column = 0;
      } else {
          ++loc->last_column;
      }
  }
}
#define YY_USER_ACTION update_loc(yylloc, yytext);

%}

LETTER [a-zA-Z]
CAPITAL [A-Z]
SMALL [a-z]
DIGIT [0-9]
IDENT [a-zA-Z0-9'_]
%START CHAR CHARESC CHAREND STRING ESCAPED

%%  /* Rules. */

<INITIAL>"("      	 return _LPAREN;
<INITIAL>")"      	 return _RPAREN;
<INITIAL>":action-type-libraries"      	 return _SYMB_2;
<INITIAL>":requirements"      	 return _SYMB_3;
<INITIAL>":types"      	 return _SYMB_4;
<INITIAL>":predicates"      	 return _SYMB_5;
<INITIAL>":modalities"      	 return _SYMB_6;
<INITIAL>":observability-groups"      	 return _SYMB_7;
<INITIAL>":action"      	 return _SYMB_8;
<INITIAL>":parameters"      	 return _SYMB_9;
<INITIAL>":where"      	 return _SYMB_10;
<INITIAL>":action-type"      	 return _SYMB_11;
<INITIAL>":precondition"      	 return _SYMB_12;
<INITIAL>":observability-conditions"      	 return _SYMB_13;
<INITIAL>":frame-of-reference"      	 return _SYMB_14;
<INITIAL>":events"      	 return _SYMB_15;
<INITIAL>":relations"      	 return _SYMB_16;
<INITIAL>":designated"      	 return _SYMB_17;
<INITIAL>":event"      	 return _SYMB_18;
<INITIAL>":postconditions"      	 return _SYMB_19;
<INITIAL>":domain"      	 return _SYMB_20;
<INITIAL>":agents"      	 return _SYMB_21;
<INITIAL>":agent-groups"      	 return _SYMB_22;
<INITIAL>"{"      	 return _LBRACE;
<INITIAL>"}"      	 return _RBRACE;
<INITIAL>":objects"      	 return _SYMB_25;
<INITIAL>":facts"      	 return _SYMB_26;
<INITIAL>":init"      	 return _SYMB_27;
<INITIAL>":model-name"      	 return _SYMB_28;
<INITIAL>"["      	 return _LBRACK;
<INITIAL>"]"      	 return _RBRACK;
<INITIAL>":model"      	 return _SYMB_31;
<INITIAL>":worlds"      	 return _SYMB_32;
<INITIAL>":valuation"      	 return _SYMB_33;
<INITIAL>":goal"      	 return _SYMB_34;
<INITIAL>"="      	 return _EQ;
<INITIAL>"<"      	 return _LT;
<INITIAL>">"      	 return _GT;
<INITIAL>"-"      	 return _MINUS;
<INITIAL>"?_"      	 return _SYMB_39;
<INITIAL>"predicate-formula"      	 return _SYMB_40;
<INITIAL>"idle-event"      	 return _SYMB_41;
<INITIAL>":del"      	 return _SYMB_42;
<INITIAL>":typing"      	 return _SYMB_43;
<INITIAL>":equality"      	 return _SYMB_44;
<INITIAL>":parameter-lists"      	 return _SYMB_45;
<INITIAL>":negative-preconditions"      	 return _SYMB_46;
<INITIAL>":disjunctive-preconditions"      	 return _SYMB_47;
<INITIAL>":existential-preconditions"      	 return _SYMB_48;
<INITIAL>":universal-preconditions"      	 return _SYMB_49;
<INITIAL>":modal-preconditions"      	 return _SYMB_50;
<INITIAL>":modal-postconditions"      	 return _SYMB_51;
<INITIAL>":ontic-change"      	 return _SYMB_52;
<INITIAL>":common-knowledge"      	 return _SYMB_53;
<INITIAL>":dynamic-common-knowledge"      	 return _SYMB_54;
<INITIAL>":ma-star"      	 return _SYMB_55;
<INITIAL>":ma-star-ontic"      	 return _SYMB_56;
<INITIAL>":ma-star-sensing"      	 return _SYMB_57;
<INITIAL>":ma-star-announcement"      	 return _SYMB_58;
<INITIAL>":ma-star-finitary-theory"      	 return _SYMB_59;
<INITIAL>":maximum-preconditions-depth"      	 return _SYMB_60;
<INITIAL>":maximum-postconditions-depth"      	 return _SYMB_61;
<INITIAL>":maximum-modal-depth"      	 return _SYMB_62;
<INITIAL>"All"      	 return _KW_All;
<INITIAL>"agent"      	 return _KW_agent;
<INITIAL>"and"      	 return _KW_and;
<INITIAL>"announcement"      	 return _KW_announcement;
<INITIAL>"as"      	 return _KW_as;
<INITIAL>"define"      	 return _KW_define;
<INITIAL>"domain"      	 return _KW_domain;
<INITIAL>"false"      	 return _KW_false;
<INITIAL>"forall"      	 return _KW_forall;
<INITIAL>"formula"      	 return _KW_formula;
<INITIAL>"if"      	 return _KW_if;
<INITIAL>"iff"      	 return _KW_iff;
<INITIAL>"imply"      	 return _KW_imply;
<INITIAL>"library"      	 return _KW_library;
<INITIAL>"literal"      	 return _KW_literal;
<INITIAL>"not"      	 return _KW_not;
<INITIAL>"ontic"      	 return _KW_ontic;
<INITIAL>"or"      	 return _KW_or;
<INITIAL>"otherwise"      	 return _KW_otherwise;
<INITIAL>"postcondition"      	 return _KW_postcondition;
<INITIAL>"predicate"      	 return _KW_predicate;
<INITIAL>"problem"      	 return _KW_problem;
<INITIAL>"sensing"      	 return _KW_sensing;
<INITIAL>"set"      	 return _KW_set;
<INITIAL>"true"      	 return _KW_true;

<INITIAL>";"[^\n]* /* skip */; /* BNFC: comment ";" */

<INITIAL>{SMALL}('|\_|({DIGIT}|{LETTER}))*    	 yylval->_string = strdup(yytext); return T_Name;
<INITIAL>{CAPITAL}(\_|({DIGIT}|{LETTER}))*    	 yylval->_string = strdup(yytext); return T_AgentName;
<INITIAL>{SMALL}('|\_|({DIGIT}|{LETTER}))*\.    	 yylval->_string = strdup(yytext); return T_ModalityName;
<INITIAL>\?{LETTER}('|\_|({DIGIT}|{LETTER}))*    	 yylval->_string = strdup(yytext); return T_Variable;
<INITIAL>\!{LETTER}('|\_|({DIGIT}|{LETTER}))*    	 yylval->_string = strdup(yytext); return T_ParameterName;
<INITIAL>{DIGIT}+      	 yylval->_int = atoi(yytext); return _INTEGER_;
<INITIAL>[ \t\r\n\f]      	 /* ignore white space. */;
<INITIAL>.      	 return _ERROR_;

%%  /* Initialization code. */

yyscan_t initialize_lexer(FILE *inp)
{
  yyscan_t scanner;
  if (yylex_init_extra(NULL, &scanner)) return 0;
  if (inp) yyrestart(inp, scanner);
  return scanner;
}

